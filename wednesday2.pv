free c: channel.

type symk.
type nonce.
type host.
free A, B: host.

fun senc(bitstring, symk): bitstring.
reduc forall x:bitstring, k: symk; sdec(senc(x,k),k) = x.

free kAS, kBS: symk[private].
event processBEnd(host).

fun nonce_to_bitstring(nonce): bitstring[data, typeConverter].
fun bitstring_to_nonce(bitstring): nonce[data, typeConverter].

let processA =
  new Na: nonce;
  out(c, (A, Na)); (* Allice sends a message to bob requesting communication*)

  in(c, (messageA: bitstring, messageForward: bitstring));
  let (bhost: host, keyAB: symk, =Na, nonceB: nonce) = sdec(messageA, kAS) in
  out(c, (messageForward, senc(nonceB, keyAB))).

let processB =
  in (c, (hostY: host, NY: nonce));

  (*Bob sends a message to the server encrypted under Kbs*)
  new Nb: nonce;
  out(c, (B, senc((hostY, NY, Nb), kBS)));

  in(c, (forward: bitstring, noncB: bitstring));
  let (=hostY, keyAB: symk) = sdec(forward, kBS) in
  let (=Nb) = sdec(noncB, keyAB) in
  processBEnd(hostY)
  .

let processS =
  in (c, (htX: host, msx: bitstring)); (*htX is hopefully B*)
  let (htY: host, Ny: nonce, Nx: nonce) = sdec(msx, kBS) in (*htY is hopefully A*)
  new kAB: symk;
  out(c, (senc((htX, kAB, Ny, Nx), kAS), senc((htY, kAB), kBS))).

process
    (*Setup host A*)
  new skA: skey;
  let pkA = pk(skA) in out(c, pkA);
  insert keys(A, pkA);
  (*Setup host B*)
  new skB: skey;
  let pkB = pk(skB) in out(c, pkB);
  insert keys(B, pkB);
  (*Setup server*)
  new skS: sskey;
  let pkS = spk(skS) in out(c, pkS);
    (
      (!processA(pkS, skA, skB)) |(*Run process A*)
      (!processB(pkS, skA, skB)) |(*Run process B*)
      (!processS(skS)) |          (*Run honest server*)
      (!processK)                 (*Key inserting process*)
       )
