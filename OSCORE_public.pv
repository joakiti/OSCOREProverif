free c: channel.

type host.
type id.
type key.
type nonce.

const emptyId:id.
const empty:bitstring.

const label_key: bitstring.
const label_iv: bitstring.

(*We imagine a server that can do 2 things, check if a lightbulb is on or off - these are to be considered payloads*)
(*Public*)
const isLightBulbTurnedOn : bitstring.
const isLightBulbTurnedOff : bitstring.
const lightbulbURIPath : bitstring.

const CoAP_GETCode : bitstring.
const CoAP_POSTCode : bitstring.
const CoAP_CHANGEDCode : bitstring.
const CoAP_CONTENTCode : bitstring.
const CoAP_EMPTYCode : bitstring.

const OSCORE_option_code : bitstring.

const acknowledgement: bitstring.
const non_confirmable: bitstring.
const confirmable: bitstring.

const coap_version_one:bitstring.
const oscore_version_one:bitstring.
const encrypt0:bitstring.
const AES_CCM: bitstring.

(* HKDF *)
const HKDF_256: bitstring.

free initiator, responder, intruder : host.

fun HKDF(bitstring, bitstring, bitstring, bitstring): key.
fun alg_key_length(bitstring, bitstring): bitstring.
fun bounded_by(bitstring):bitstring.
fun aeadEncrypt(key, nonce, bitstring, bitstring): bitstring.

free msg1id, msg2id : bitstring[private].

fun aeadNonce(id, bitstring, key) : nonce.

reduc forall plaintext: bitstring, n: nonce, k: key, aad: bitstring; aeadDecrypt(aeadEncrypt(k, n, plaintext, aad), k, n, aad) = plaintext.
reduc forall plaintext: bitstring, n: nonce, k: key, aad: bitstring; decrypt(aeadEncrypt(k, n, plaintext, aad), k, n) = plaintext.

table security_context_lookup(host, host, id, id, bitstring, bitstring, bitstring).
table token_to_message_lookup(host, bitstring, bitstring).
table replay_window(host, bitstring).

(*Forward secrecy*)
query attacker(msg1id) phase 1.
query attacker(msg2id) phase 1.

(*Secrecy*)
(*This is false because the attacker is part of the model, and the processes willingly send their secret to him*)
query attacker(msg1id) phase 0.
query attacker(msg2id) phase 0.

event beginInitiator(host, host).
event beginResponder(host, host).

event endResponder(host, host).
event endInitiator(host, host).

event here.

query event(here).

(*Injective agreement*)
(*This is false, as it should be, because we dont have the replay window functionality in place*)
query init:host, res:host; inj-event(endResponder(init, res)) ==> inj-event(beginInitiator(init, res)).

(*This is true, however, it should not be. There is nothing stopping an attacker from replaying a message.*)
query init:host, res:host; inj-event(endInitiator(init, res)) ==> inj-event(endResponder(init, res)).


let oscore_initiator =
  in(c, identity:host);
  if identity = initiator || identity = responder then
    new token : bitstring;
    new messageid : bitstring;
    new partial_iv: bitstring;
    in(c, endpoint: host);
      event beginInitiator(identity, endpoint);
    get security_context_lookup(=identity, =endpoint, senderID:id, recipientID:id, msecret:bitstring, msalt:bitstring, idcontext:bitstring) in
      let cvInfo = (emptyId, idcontext, AES_CCM, label_iv) in let CommonIv = HKDF(msecret, msalt, cvInfo, alg_key_length(AES_CCM, label_iv)) in
      let senderInfo = (senderID, idcontext, AES_CCM, label_key) in let senderKey = HKDF(msecret, msalt, senderInfo, alg_key_length(AES_CCM, label_key)) in

      let aad = (encrypt0, oscore_version_one, AES_CCM, senderID, partial_iv) in
      let aead_nonce = aeadNonce(senderID, partial_iv, CommonIv) in
      let plaintext = ((CoAP_GETCode, isLightBulbTurnedOn), msg1id) in
      let ciphertext = aeadEncrypt(senderKey, aead_nonce, plaintext, aad) in
      let oscore_option = (partial_iv, senderID, idcontext) in
      let security_context = (endpoint, senderID, recipientID, idcontext, partial_iv, aead_nonce) in
      insert token_to_message_lookup(identity, token, security_context);

      if endpoint <> intruder then
        let msg_1 = (non_confirmable, CoAP_POSTCode, messageid, token, oscore_option, ciphertext) in
        out(c, msg_1)
      else (
        let plaintext = ((CoAP_GETCode, isLightBulbTurnedOn)) in
        let ciphertext = aeadEncrypt(senderKey, aead_nonce, plaintext, aad) in
        let msg_1 = (non_confirmable, CoAP_POSTCode, messageid, token, oscore_option, ciphertext) in
        out(c, msg_1)
        ).


let oscore_initiator_response_receiver =
  in(c, identity:host);
  if identity = initiator || identity = responder then
  in(c, (T:bitstring, dummyCode : bitstring, messageid : bitstring, token: bitstring, OSCORE:bitstring, ciphertext:bitstring)); (*The encrypted payload*)
  if OSCORE = empty then
  (
    get token_to_message_lookup(=identity, =token, security_context:bitstring) in
    let (endpoint:host, senderID:id, recipientID:id, idcontext:bitstring, partial_iv:bitstring, aead_nonce:nonce) = security_context in
    get security_context_lookup(=identity, =endpoint, =senderID, =recipientID, msecret:bitstring, msalt:bitstring, =idcontext) in (*Find a security context with endpoint*)
    let aad = (encrypt0, oscore_version_one, AES_CCM, senderID, partial_iv) in
    let recipientInfo = (recipientID, idcontext, AES_CCM, label_key) in let recipientKey = HKDF(msecret, msalt, recipientInfo, alg_key_length(AES_CCM, label_key)) in
    let (plaintext:bitstring, identifier:bitstring) = aeadDecrypt(ciphertext, recipientKey, aead_nonce, aad) in
    if endpoint = initiator || endpoint = responder then
    event endInitiator(identity, endpoint);
    event here
  )
  else
  (*Derive a new aead nonce*)
  0.

let oscore_responder =
  in(c, identity:host);
  if identity = initiator || identity = responder then
    in(c, (T:bitstring, dummyCode : bitstring, messageid : bitstring, token: bitstring, OSCORE:bitstring, ciphertext:bitstring));
    let (partial_iv:bitstring, recipientID:id, idcontext:bitstring) = OSCORE in
    (
      if T = confirmable then
        out(c, (acknowledgement, CoAP_EMPTYCode, messageid))
    )
      |
    (
      get security_context_lookup(=identity, endpoint:host, senderID:id, =recipientID, msecret:bitstring, msalt:bitstring, =idcontext) in (*Find a security context with endpoint*)
        event beginResponder(endpoint, identity);
      let cvInfo = (emptyId, idcontext, AES_CCM, label_iv) in let commonIV = HKDF(msecret, msalt, cvInfo, alg_key_length(AES_CCM, label_iv)) in
      let recipientInfo = (recipientID, idcontext, AES_CCM, label_key) in let recipientKey = HKDF(msecret, msalt, recipientInfo, alg_key_length(AES_CCM, label_key)) in
      let aad = (encrypt0, oscore_version_one, AES_CCM, recipientID, partial_iv) in
      let aead_nonce = aeadNonce(recipientID, partial_iv, commonIV) in

      let (plaintextreceived:bitstring, identifier:bitstring) = aeadDecrypt(ciphertext, recipientKey, aead_nonce, aad) in

      new responseId : bitstring;
      let responsePayload = bounded_by(plaintextreceived) in (*Response payload is bounded by the plaintext*)
      let sender_info = (senderID, idcontext, AES_CCM, label_key) in let senderKey = HKDF(msecret, msalt, sender_info, alg_key_length(AES_CCM, label_key)) in
      let sender_ciphertext = aeadEncrypt(senderKey, aead_nonce, ((CoAP_CONTENTCode, responsePayload), msg2id), aad) in
      let msg_2 = (non_confirmable, CoAP_CHANGEDCode, responseId, token, empty, sender_ciphertext) in

      if endpoint <> intruder then
        event endResponder(endpoint, identity);
        out(c, msg_2)
      else (
        let responsePayload = bounded_by(plaintextreceived) in (*Response payload is bounded by the plaintext*)
        let sender_ciphertext = aeadEncrypt(senderKey, aead_nonce, (CoAP_CONTENTCode, responsePayload), aad) in
        let msg_2 = (non_confirmable, CoAP_CHANGEDCode, responseId, token, empty, sender_ciphertext) in
        out(c, msg_2)
        )
  ).

  process
    new IDir:id; new IDri:id; new msecret : bitstring; new msalt:bitstring; new idcontext: bitstring;
    new AttackIDir:id; new AttackIDri:id; new Attackmsecret : bitstring; new Attackmsalt:bitstring; new Attackidcontext: bitstring;
    out(c, (AttackIDir, AttackIDri, Attackmsecret, Attackmsalt, Attackidcontext));
    (*Consider a shared table where all users are well behaved, and ONLY reads rows which belongs to them*)
    insert security_context_lookup(initiator, responder, IDir, IDri, msecret, msalt, idcontext);
    insert security_context_lookup(responder, initiator, IDri, IDir, msecret, msalt, idcontext);

    insert security_context_lookup(initiator, intruder, AttackIDir, AttackIDri, Attackmsecret, Attackmsalt, Attackidcontext);
    insert security_context_lookup(intruder, initiator, AttackIDri, AttackIDir, Attackmsecret, Attackmsalt, Attackidcontext);

    insert security_context_lookup(intruder, responder, AttackIDir, AttackIDri, Attackmsecret, Attackmsalt, Attackidcontext);
    insert security_context_lookup(responder, intruder, AttackIDri, AttackIDir, Attackmsecret, Attackmsalt, Attackidcontext);
    (*These are the actors in our model*)
    out(c, (IDir, IDri, idcontext));

    (!oscore_initiator) |
    (!oscore_responder) |
    (!oscore_initiator_response_receiver) |

    (phase 1; out(c, (msecret, msalt)))
