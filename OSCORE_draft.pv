free c: channel.

(*CoAP*)
type CoAP_Message[data].
type CoAP_header[data].
type CoAP_token[data].
type CoAP_option[data].
type CoAP_payload[data].
type CoAP_version[data].
type CoAP_confirmCode[data].
type CoAP_tokenlength[data].
type CoAP_MessageCode[data].
type CoAP_messageID[data].

type host.

(*Cryptographic elements*)
type id. (* Initiator / Responder ID, aka. KID *)
type key. (* Initiator / Responder key*)
type nonce. (* AEAD Nonce *)
type additional_data. (* Additional data for AEAD *)
type encrypt0_structure.
type external_aad.
type iv. (*Common IV or Partial IV*)
type aead_algorithm.
type oscore_version.
type COSE_ciphertext.
type id_context.

free label_key: bitstring.
free label_iv: bitstring.

(*Type of algorithm + key or iv label*)
fun alg_key_length(aead_algorithm, bitstring) : bitstring.

(*Bitstring should be label_key or label_iv*)
fun info(id, id_context, aead_algorithm, bitstring): bitstring[data].

(*Master Secret, Master Salt, Info, Length of key*)
fun HKDF(bitstring, bitstring, bitstring, bitstring): bitstring.
reduc forall master_secret: bitstring, master_salt:bitstring, i:id, ic:id_context, ag:aead_algorithm, lab:bitstring;
  getAlgorithm(HKDF(master_secret,master_salt, info(i,ic,ag, lab), alg_key_length(ag,lab))) = ag.
fun toKey(bitstring):key.
fun toIV(bitstring):iv.



(*Options*)
free emptyIv: iv.
free emptyId: id.
free emptyIdC: id_context.
fun CoAP_Option_OSCORE(iv, id, id_context): CoAP_option[data].

(*Codes*)
free CoAP_versionOne: CoAP_version.
free CoAP_confirmable: CoAP_confirmCode.
free CoAP_nonConfirm: CoAP_confirmCode.

free CoAP_GETCode : CoAP_MessageCode.
free CoAP_POSTCode : CoAP_MessageCode.
free CoAP_CHANGEDCode : CoAP_MessageCode.

free oscore_version_one : oscore_version.
free default_aead_algorithm : aead_algorithm.
free encrypt0_context : bitstring.

(*Constructors*)
fun Header(CoAP_version, CoAP_confirmCode, CoAP_tokenlength, CoAP_MessageCode, CoAP_messageID) : CoAP_header[data].
fun Request(CoAP_header, CoAP_token, CoAP_option, CoAP_payload) : CoAP_Message[data].
fun CoAP_tokenLength(CoAP_token): CoAP_tokenlength.

(* Default options. TODO: Delete? *)


(* Note that the AAD consists of a fixed string of 11 bytes concatenated
    with the external_aad. *)
fun encrypt0(oscore_version, aead_algorithm, id, iv) : external_aad[data].
fun AAD(bitstring, external_aad) : additional_data[data].

(*Sender ID, CommonIV, PartialIV*)
fun aead_nonce(id, iv, iv) : nonce.

event Reveal(key).
event IvReveal(iv).
event PartialIvReplay(iv).
event here.
event respondFinish(iv).
event partialIvAccepted(iv).
event beginAparam(host).
event endAparam(host).
event beginBparam(host).
event endBparam(host).

fun COSE(iv, id, COSE_ciphertext): bitstring[data].

fun enc_COSE_ciphertext(key, nonce, bitstring, additional_data): COSE_ciphertext.
fun payload_from_ciphertext(COSE_ciphertext):CoAP_payload[data].
fun emptyPayload(): CoAP_payload.
fun generateResponsePayload(CoAP_MessageCode, CoAP_payload): CoAP_payload.
fun generateResponseCode(CoAP_MessageCode, CoAP_payload): CoAP_MessageCode.

reduc forall k:key, n:nonce, plain: bitstring, add:additional_data;
  dec_COSE_ciphertext(enc_COSE_ciphertext(k,n,plain,add), k, n, add) = plain.
reduc forall k:key, n:nonce, plain: bitstring, add:additional_data;
  dec_COSE_ciphertext_no_ad(enc_COSE_ciphertext(k,n,plain,add), k, n) = plain.

(*Host is owner, second host is endpoint, sender id, recipient id, master secret, master salt, idcontext*)
table security_context_lookup(host, host, id, id, bitstring, bitstring, id_context).
table unique_ivs(iv).

free initiator, responder : host.

let oscore_initiator(identity : host) =
  new token : CoAP_token; new messageID : CoAP_messageID;
  new payload : CoAP_payload; new partial_iv: iv;
  in(c, (endpoint:host)); (*The attacker decides an endpoint to communicate with*)
  (* 1. Retrieve the Sender Context associated with the target resource. How is this done exactly?*)
  (* In this implementation, the "sender" has a table of hosts he can communicate with, they include id's, etc.*)
  event beginBparam(responder);
  get security_context_lookup(=identity, =endpoint, IDir:id, IDri:id, msecret:bitstring, msalt:bitstring, idcontext:id_context) in (*Find a security context with endpoint*)
  (*
    An endpoint may free up memory by not storing the Common IV, Sender Key, and
    Recipient Key, deriving them when needed.
  *)
  let CVInfo = info(emptyId, idcontext, default_aead_algorithm, label_iv) in let CommonIv = toIV(HKDF(msecret, msalt, CVInfo, alg_key_length(default_aead_algorithm, label_iv))) in
  let KirInfo = info(IDir, idcontext, default_aead_algorithm, label_key) in let Kir = toKey(HKDF(msecret, msalt, KirInfo, alg_key_length(default_aead_algorithm, label_key))) in
  let KriInfo = info(IDri, idcontext, default_aead_algorithm, label_key) in let Kri = toKey(HKDF(msecret, msalt, KriInfo, alg_key_length(default_aead_algorithm, label_key))) in
  let version = CoAP_versionOne in let confirm = CoAP_nonConfirm in
  let tlength = CoAP_tokenLength(token) in let rcode = CoAP_POSTCode in
  (* 2. Compose the Additional Authenticated Data and the plaintext*)
  (* AAD = Enc_structure = [ "Encrypt0", h’’, external_aad ]. Not sure what h'' is. *)
  let aad = AAD(encrypt0_context, encrypt0(oscore_version_one, default_aead_algorithm, IDir, partial_iv)) in
  (*
  o the Code of the original CoAP message
  o all Inner option message fields present in the original CoAP message
  o the Payload of original CoAP message, if present, and in that case
    prefixed by the one-byte Payload Marker (0xff).
  *)
  let secret_plaintext = (rcode, payload) in (*This early draft assumes no Class E option, and no prefix*)

  (* 3. Encode the Partial IV. (Sender sequence number). Compute
  the AEAD nonce from the Sender ID, Common IV, and Partial IV*)
  let aeadnonce = aead_nonce(IDir, CommonIv, partial_iv) in

  (*Encrypt the COSE object using the Sender Key.*)
  let ciphertext = enc_COSE_ciphertext(Kir, aeadnonce, secret_plaintext, aad) in
  let COSEobject = COSE(partial_iv, IDir, ciphertext) in
  (*it might not make sense to do it like this in ProVerif*)
  (*The oscore option contains a compressed COSE object with it's unprotected fields*)
  let OSCORE_OPTION = CoAP_Option_OSCORE(partial_iv, IDir, idcontext) in
  (*The oscore request should contain a dummy code*)
  let dummyCode = CoAP_GETCode in
  (*The payload from the original CoAP message is encrypted in COSE and then added as payload*)
  let header = Header(version, confirm, tlength, dummyCode, messageID) in
  let request = Request(header, token, OSCORE_OPTION, payload_from_ciphertext(ciphertext)) in
  out(c, request);
  (*Receive a response*)
  in(c, response:CoAP_Message);
  let Request(resheader, restoken, resoption, respayload) = response in
  let Header(resversion, resconfirmCode, restlength, resrequestCode, resmessageId) = resheader in
  if restoken = token then (*Bind response to request*)
  if resoption = CoAP_Option_OSCORE(emptyIv, emptyId, emptyIdC) then
  let responseAad = AAD(encrypt0_context, encrypt0(oscore_version_one, default_aead_algorithm, IDri, partial_iv)) in
  let payload_from_ciphertext(p) = respayload in
  let (rescode : CoAP_MessageCode, decryptedPayload : CoAP_payload) = dec_COSE_ciphertext(p, Kri, aeadnonce, responseAad) in
  event endAparam(identity);
  event here;
  0.

let oscore_responder(identity : host) =
  in(c, req:CoAP_Message);
  let Request(reqheader, token, option, payload) = req in let Header(version, confirmCode, tlength, requestCode, messageId) = reqheader in
  let CoAP_Option_OSCORE(partial_iv, kid, idcontext) = option in let payload_from_ciphertext(p) = payload in

  get security_context_lookup(=identity, endpoint:host, IDri:id, =kid, msecret:bitstring, msalt:bitstring, =idcontext) in (*Find a security context with endpoint*)
  event beginAparam(endpoint); (*Event that protocol started in processB *)
  let CVInfo = info(emptyId, idcontext, default_aead_algorithm, label_iv) in let CommonIv = toIV(HKDF(msecret, msalt, CVInfo, alg_key_length(default_aead_algorithm, label_iv))) in
  let KirInfo = info(kid, idcontext, default_aead_algorithm, label_key) in let Kir = toKey(HKDF(msecret, msalt, KirInfo, alg_key_length(default_aead_algorithm, label_key))) in
  let KriInfo = info(IDri, idcontext, default_aead_algorithm, label_key) in let Kri = toKey(HKDF(msecret, msalt, KriInfo, alg_key_length(default_aead_algorithm, label_key))) in
  (*Compose AAD*)
  let aad = AAD(encrypt0_context, encrypt0(oscore_version_one, default_aead_algorithm, kid, partial_iv)) in
  (*Compute the AEAD Nonce*)
  let aeadnonce = aead_nonce(kid, CommonIv, partial_iv) in
  (*Decrypt the COSE object*)
  let (rcode : CoAP_MessageCode, decryptedPayload : CoAP_payload) = dec_COSE_ciphertext(p, Kir, aeadnonce, aad) in
  (*If we get the same we execute partialreplay event, otherwise, we continue.*)
  get unique_ivs(partial:iv) suchthat partial = partial_iv in event PartialIvReplay(partial_iv) else
  event partialIvAccepted(partial_iv);
  (*keep track of used unique_ivs*)
  insert unique_ivs(partial_iv);

  (*Generate response*)
  let responsePayload = generateResponsePayload(rcode, decryptedPayload) in
  let responseCode = generateResponseCode(rcode, decryptedPayload) in
  let response_secret_plaintext = (responseCode, responsePayload) in (*This early draft assumes no Class E option*)
  let responseAad = AAD(encrypt0_context, encrypt0(oscore_version_one, default_aead_algorithm, IDri, partial_iv)) in
  let ciphertext = enc_COSE_ciphertext(Kri, aeadnonce, response_secret_plaintext, responseAad) in
  let COSEobject = COSE(partial_iv, IDri, ciphertext) in

  (*We use the AEAD nonce from the request.*)
  let responseDummyCode = CoAP_CHANGEDCode in
  let OSCORE_OPTION = CoAP_Option_OSCORE(emptyIv, emptyId, emptyIdC) in
  new responseMessageId : CoAP_messageID;
  let header = Header(CoAP_versionOne,  CoAP_nonConfirm, CoAP_tokenLength(token), responseDummyCode, responseMessageId) in
  let request = Request(header, token, OSCORE_OPTION, payload_from_ciphertext(ciphertext)) in
  event endBparam(identity);
  out(c, request).

let generate_new_security_context_initiator(IDir: id) =
  0.
  (*Create the ID Context parameter*)


query Kir:key; attacker(new payload) ==> event (Reveal(Kir)).
query CommonIv:iv; attacker(new payload) ==> event (IvReveal(CommonIv)).
query x: host, CommonIv:iv, Kir:key; inj-event(endBparam(x)) ==> (inj-event(beginBparam(x)) || event(IvReveal(CommonIv)) || event(Reveal(Kir))).
query x: host, CommonIv:iv, Kir:key; inj-event(endAparam(x)) ==> (inj-event(beginAparam(x)) || event(IvReveal(CommonIv)) || event(Reveal(Kir))).

(*This query is acting weird, ask Alessandro:*)
(*Got it working, but still.. is it sound?*)
query partialiv:iv; event (PartialIvReplay(partialiv)) ==>  event(partialIvAccepted(partialiv)).

query CommonIv:iv, Kir:key; event(here) ==> event(IvReveal(CommonIv)) || event(Reveal(Kir)).

(*This process allows security contexts to be derived where the security context is not derived by processes themself.
  E.g
*)
let init =
  in(c, (a: host, b: host, aid:id, bid:id, ms: bitstring, msalt:bitstring, idcontext: id_context));
  if a <> initiator && b <> responder then
    if b <> initiator && a <> responder then
      insert security_context_lookup(a, b, aid, bid, ms, msalt, idcontext);
      insert security_context_lookup(b, a, bid, aid, ms, msalt, idcontext).

process
  new IDir:id; new IDri:id; new msecret : bitstring; new msalt:bitstring; new idcontext: id_context;
  out(c, idcontext);
  (*Consider a shared table where all users are well behaved, and ONLY reads rows which belongs to them*)
  insert security_context_lookup(initiator, responder, IDir, IDri, msecret, msalt, idcontext);
  insert security_context_lookup(responder, initiator, IDri, IDir, msecret, msalt, idcontext);
  (*These are the actors in our model*)
  (!oscore_initiator(initiator)) | (!oscore_responder(responder)) | (!init) |
  (
    (*What if the attacker has the keys, can he get the payload?*)
    let CVInfo = info(emptyId, idcontext, default_aead_algorithm, label_iv) in let CommonIv = toIV(HKDF(msecret, msalt, CVInfo, alg_key_length(default_aead_algorithm, label_iv))) in
    let KirInfo = info(IDir, idcontext, default_aead_algorithm, label_key) in let Kir = toKey(HKDF(msecret, msalt, KirInfo, alg_key_length(default_aead_algorithm, label_key))) in
    let KriInfo = info(IDri, idcontext, default_aead_algorithm, label_key) in let Kri = toKey(HKDF(msecret, msalt, KriInfo, alg_key_length(default_aead_algorithm, label_key))) in
      (event Reveal(Kir); out(c, Kir)) |
      (event Reveal(Kri); out(c, Kri)) |
      (event IvReveal(CommonIv); out(c, CommonIv))
  )
