free c: channel.

(*CoAP*)
type CoAP_Message[data].
type CoAP_header[data].
type CoAP_token[data].
type CoAP_options[data].
type CoAP_option[data].
type CoAP_payload[data].
type CoAP_version[data].
fun CoAP_versionOne(): CoAP_version.
type CoAP_confirmCode[data].
fun CoAP_confirmable(): CoAP_confirmCode.
fun CoAP_nonConfirm(): CoAP_confirmCode.
type CoAP_tokenlength[data].
fun CoAP_tokenLength(CoAP_token): CoAP_tokenlength.
type CoAP_MessageCode[data].
type CoAP_messageID[data].

type host.

(*Cryptographic elements*)
type id. (* Initiator / Responder ID, aka. KID *)
type key. (* Initiator / Responder key*)
type nonce. (* AEAD Nonce *)
type additional_data. (* Additional data for AEAD *)
type encrypt0_structure.
type external_aad.
type iv. (*Common IV or Partial IV*)
type aead_algorithm.
type oscore_version.
type COSE_ciphertext.


free emptyIdContext: bitstring.
free emptyId: id.
free type_key: bitstring.
free type_iv: bitstring.

fun info(id, bitstring, aead_algorithm, bitstring, bitstring):bitstring[data].

fun lengthOfKey(aead_algorithm): bitstring.

fun prk_hmac_sha_256(bitstring, bitstring): bitstring.
fun genKey(bitstring):key.
fun genKey(bitstring):key.

(*Options*)
fun CoAP_Option_OSCORE_Option(iv, id) : CoAP_option[data].
fun CoAP_Option_OSCORE_Option_context(iv, id, bitstring) : CoAP_option[data].
fun CoAP_Option_OSCORE_Option_empty() : CoAP_option[data].
free CoAP_EmptyOption : CoAP_option.

(*Codes*)
free CoAP_GETCode : CoAP_MessageCode.
free CoAP_POSTCode : CoAP_MessageCode.
free CoAP_CHANGEDCode : CoAP_MessageCode.

(*Constructors*)
fun Header(CoAP_version, CoAP_confirmCode, CoAP_tokenlength, CoAP_MessageCode, CoAP_messageID) : CoAP_header[data].
fun Request(CoAP_header, CoAP_token, CoAP_option, CoAP_payload) : CoAP_Message[data].

(* Default options. TODO: Delete? *)
free oscore_version_one : oscore_version.
free default_aead_algorithm : aead_algorithm.
free encrypt0_context : bitstring.

(* Note that the AAD consists of a fixed string of 11 bytes concatenated
    with the external_aad. *)
fun encrypt0(oscore_version, aead_algorithm, id, iv) : external_aad[data].
fun AAD(bitstring, external_aad) : additional_data[data].
(*Sender ID, CommonIV, PartialIV*)
fun aead_nonce(id, iv, iv) : nonce.

event Reveal(key).
event IvReveal(iv).
event PartialIvReplay(iv).
event here.
event respondFinish(iv).
event partialIvAccepted(iv).
event beginAparam(host).
event endAparam(host).
event beginBparam(host).
event endBparam(host).

type COSEObject.
fun enc_COSE_ciphertext(key, nonce, bitstring, additional_data): COSE_ciphertext.
fun payload_from_ciphertext(COSE_ciphertext):CoAP_payload[data].
fun emptyPayload(): CoAP_payload.
fun generateResponsePayload(CoAP_MessageCode, CoAP_payload): CoAP_payload.
fun generateResponseCode(CoAP_MessageCode, CoAP_payload): CoAP_MessageCode.

(*
Have we understood this correctly that it is possible to decrypt the plaintext without using add?
*)
reduc forall k:key, n:nonce, plain: bitstring, add:additional_data;
  dec_COSE_ciphertext(enc_COSE_ciphertext(k,n,plain,add), k, n, add) = plain.
reduc forall k:key, n:nonce, plain: bitstring, add:additional_data;
  dec_COSE_ciphertext_no_ad(enc_COSE_ciphertext(k,n,plain,add), k, n) = plain.

(*
To simplify retrieval of the right Recipient Context, the Recipient
ID SHOULD be unique in the sets of all Recipient Contexts used by an
endpoint.  If an endpoint has the same Recipient ID with different
Recipient Contexts, i.e. the Recipient Contexts are derived from
different Common Contexts, then the endpoint may need to try multiple
times before verifying the right security context associated to the
Recipient ID.

Is this how it's done now? Can't really confirm

It remains to prove that the nonces used by the fixed endpoint are unique. Interesting?

I need help with Verifying this entire document - and making it greater in the same way we did last time.

I need help creating the "matching of tokens" part.

I need help creating the ID Context and multiple security contexts (e.g how do i enumerate the sender sequence number so it starts from 0 and adds up)

I need help verifying that a replay attack can happen, because it should be able of if we remove the partial iv check, but it doesn't occur.

I need help creating the single security context deriviation - it relies on restoring the sender sequence number.

We need to take a look at the COSE structure

I, am not entirely sure what the messaging layer means
Since the message formats for CoAP over unreliable transport [RFC7252] and for CoAP over reliable transport [RFC8323]
differ only in terms of CoAP Messaging Layer, OSCORE can be applied to both unreliable and reliable transports

the original CoAP/HTTP message is translated to CoAP
(if not already in CoAP) and protected in a COSE object. - this is strange

In a piggybacked response, the Message ID of the Confirmable
request and the Acknowledgement MUST match, and the tokens of the
response and original request MUST match.
    ---> In a separate response, just the tokens of the response and original request MUST match. <---
What we have now^ should we consider doing piggybacked ACK responses? I dont think they will make a difference for OSCORE.
     *)
table security_context_lookup(host, host, id, id, bitstring, bitstring).
(*OSCORE requires that client and server establish a shared security
 context used to process the COSE objects.*)

 (* The endpoints protect messages to send using the Sender Context and
 verify messages received using the Recipient Context, both contexts
 being derived from the Common Context and other data. Clients and
 servers need to be able to retrieve the correct security context to
 use.

In this model there is on notion of a context, all data is accessible for both parties out of the box.

*)
table context(key, id, key, id, iv).
table unique_ivs(iv).

fun COSE(iv, id, COSE_ciphertext): COSEObject[data].

free initiator, responder : host.

let oscore_initiator(identity : host) =
  new token : CoAP_token; new messageID : CoAP_messageID;
  new payload : CoAP_payload; new partial_iv: iv;
  in(c, (endpoint:host)); (*The attacker decides an endpoint to communicate with*)
  (* 1. Retrieve the Sender Context associated with the target resource. How is this done exactly?*)
  (* In this implementation, the "sender" has a table of hosts he can communicate with, they include id's, etc.*)
  event beginBparam(responder);
  get security_context_lookup(=identity, =endpoint, IDir:id, IDri:id, msecret:bitstring, msalt:bitstring, idcontext:bitstring) in (*Find a security context with endpoint*)
  (*
    An endpoint may free up memory by not storing the Common IV, Sender Key, and
    Recipient Key, deriving them when needed.
  *)
  let commoniv = prk(prk_hmac_sha_256(msecret, msalt), info(emptyId, idcontext, default_aead_algorithm, type_iv, lengthOfKey(default_aead_algorithm))) in
  let Kir = derive_key_context(msecret, IDir, default_aead_algorithm, idcontext) in
  let Kri = derive_key_context(msecret, IDri, default_aead_algorithm, idcontext) in
  let version = CoAP_versionOne in let confirm = CoAP_nonConfirm in
  let tlength = CoAP_tokenLength(token) in let rcode = CoAP_POSTCode in
  (* 2. Compose the Additional Authenticated Data and the plaintext*)
  (* AAD = Enc_structure = [ "Encrypt0", h’’, external_aad ]. Not sure what h'' is. *)
  let aad = AAD(encrypt0_context, encrypt0(oscore_version_one, default_aead_algorithm, IDir, partial_iv)) in
  (*
  o the Code of the original CoAP message
  o all Inner option message fields present in the original CoAP message
  o the Payload of original CoAP message, if present, and in that case
    prefixed by the one-byte Payload Marker (0xff).
  *)
  let secret_plaintext = (rcode, payload) in (*This early draft assumes no Class E option, and no prefix*)

  (* 3. Encode the Partial IV. (Sender sequence number). Compute
  the AEAD nonce from the Sender ID, Common IV, and Partial IV*)
  let aeadnonce = aead_nonce(IDir, CommonIv, partial_iv) in

  (*Encrypt the COSE object using the Sender Key.*)
  let ciphertext = enc_COSE_ciphertext(Kir, aeadnonce, secret_plaintext, aad) in
  let COSEobject = COSE(partial_iv, IDir, ciphertext) in
  (*it might not make sense to do it like this in ProVerif*)
  (*The oscore option contains a compressed COSE object with it's unprotected fields*)
  let OSCORE_OPTION = CoAP_Option_OSCORE_Option_context(partial_iv, IDir, idcontext) in
  (*The oscore request should contain a dummy code*)
  let dummyCode = CoAP_GETCode in
  (*The payload from the original CoAP message is encrypted in COSE and then added as payload*)
  let header = Header(version, confirm, tlength, dummyCode, messageID) in
  let request = Request(header, token, OSCORE_OPTION, payload_from_ciphertext(ciphertext)) in
  out(c, request);
  (*Receive a response*)
  in(c, response:CoAP_Message);
  let Request(resheader, restoken, resoption, respayload) = response in
  let Header(resversion, resconfirmCode, restlength, resrequestCode, resmessageId) = resheader in
  if restoken = token then (*Bind response to request*)
  if resoption = CoAP_Option_OSCORE_Option_empty() then
  let responseAad = AAD(encrypt0_context, encrypt0(oscore_version_one, default_aead_algorithm, IDri, partial_iv)) in
  let payload_from_ciphertext(p) = respayload in
  let (rescode : CoAP_MessageCode, decryptedPayload : CoAP_payload) = dec_COSE_ciphertext(p, Kri, aeadnonce, responseAad) in
  event endAparam(identity);
  event here;
  0.

let oscore_responder(identity : host) =
  (************************)
  (*  Verifying request   *)
  (************************)
  in(c, req:CoAP_Message);
  let Request(reqheader, token, option, payload) = req in
  let Header(version, confirmCode, tlength, requestCode, messageId) = reqheader in
  let CoAP_Option_OSCORE_Option_context(partial_iv, kid, idcontext) = option in
  let payload_from_ciphertext(p) = payload in
  (*Decompress the COSE Object. TODO: Implement decompression?*)
  (*KEY + COMMON_IV*)
  get security_context_lookup(=identity, endpoint:host, IDri:id, =kid, msecret:bitstring, msalt:bitstring, =idcontext) in (*Find a security context with endpoint*)
  event beginAparam(endpoint); (*Event that protocol started in processB *)
  let CommonIv = derive_common_iv_context(msecret, idcontext, default_aead_algorithm) in
  let Kir = derive_key_context(msecret, kid, default_aead_algorithm, idcontext) in
  let Kri = derive_key_context(msecret, IDri, default_aead_algorithm, idcontext) in
  (*Compose AAD*)
  let aad = AAD(encrypt0_context, encrypt0(oscore_version_one, default_aead_algorithm, kid, partial_iv)) in
  (*Compute the AEAD Nonce*)
  let aeadnonce = aead_nonce(kid, CommonIv, partial_iv) in
  (*Decrypt the COSE object*)
  let (rcode : CoAP_MessageCode, decryptedPayload : CoAP_payload) = dec_COSE_ciphertext(p, Kir, aeadnonce, aad) in
  (*If we get the same we execute partialreplay event, otherwise, we continue.*)
  get unique_ivs(partial:iv) suchthat partial = partial_iv in event PartialIvReplay(partial_iv) else
  event partialIvAccepted(partial_iv);
  (*keep track of used unique_ivs*)
  insert unique_ivs(partial_iv);

  (*Generate response*)
  let responsePayload = generateResponsePayload(rcode, decryptedPayload) in
  let responseCode = generateResponseCode(rcode, decryptedPayload) in
  let response_secret_plaintext = (responseCode, responsePayload) in (*This early draft assumes no Class E option*)
  let responseAad = AAD(encrypt0_context, encrypt0(oscore_version_one, default_aead_algorithm, IDri, partial_iv)) in
  let ciphertext = enc_COSE_ciphertext(Kri, aeadnonce, response_secret_plaintext, responseAad) in
  let COSEobject = COSE(partial_iv, IDri, ciphertext) in

  (*We use the AEAD nonce from the request.*)
  let responseDummyCode = CoAP_CHANGEDCode in
  let OSCORE_OPTION = CoAP_Option_OSCORE_Option_empty in
  new responseMessageId : CoAP_messageID;
  let header = Header(CoAP_versionOne(),  CoAP_nonConfirm(), CoAP_tokenLength(token), responseDummyCode, responseMessageId) in
  let request = Request(header, token, OSCORE_OPTION, payload_from_ciphertext(ciphertext)) in
  event endBparam(identity);
  out(c, request).

let generate_new_security_context_initiator(IDir: id) =
  0.
  (*Create the ID Context parameter*)


query Kir:key; attacker(new payload) ==> event (Reveal(Kir)).
query CommonIv:iv; attacker(new payload) ==> event (IvReveal(CommonIv)).
query x: host, CommonIv:iv, Kir:key; inj-event(endBparam(x)) ==> (inj-event(beginBparam(x)) || event(IvReveal(CommonIv)) || event(Reveal(Kir))).
query x: host, CommonIv:iv, Kir:key; inj-event(endAparam(x)) ==> (inj-event(beginAparam(x)) || event(IvReveal(CommonIv)) || event(Reveal(Kir))).

(*This query is acting weird, ask Alessandro:*)
(*Got it working, but still.. is it sound?*)
query partialiv:iv; event (PartialIvReplay(partialiv)) ==>  event(partialIvAccepted(partialiv)).

query CommonIv:iv, Kir:key; event(here) ==> event(IvReveal(CommonIv)) || event(Reveal(Kir)).

(*This process allows security contexts to be derived where the security context is not derived by processes themself.
  E.g
*)
let init =
  in(c, (a: host, b: host, aid:id, bid:id, msecret: bitstring, msalt:bitstring, idcontext: bitstring));
  if a <> initiator && b <> responder then
    if b <> initiator && a <> responder then
      insert security_context_lookup(a, b, aid, bid, msecret, msalt, idcontext);
      insert security_context_lookup(b, a, bid, aid, msecret, msalt, idcontext).

process
  new IDir:id; new IDri:id; new MasterSecret : bitstring; new idcontext: bitstring; new MasterSalt:bitstring;
  out(c, idcontext);
  (*Consider a shared table where all users are well behaved, and ONLY reads rows which belongs to them*)
  insert security_context_lookup(initiator, responder, IDir, IDri, MasterSecret, MasterSalt, idcontext);
  insert security_context_lookup(responder, initiator, IDri, IDir, MasterSecret, MasterSalt, idcontext);
  (*These are the actors in our model*)
  (!oscore_initiator(initiator)) | (!oscore_responder(responder)) | (!init) |
  (
    (*What if the attacker has the keys, can he get the payload?*)
    let CommonIv = derive_common_iv_context(MasterSecret, idcontext, default_aead_algorithm) in
    let Kir = derive_key_context(MasterSecret, IDir, default_aead_algorithm, idcontext) in
    let Kri = derive_key_context(MasterSecret, IDri, default_aead_algorithm, idcontext) in
      (event Reveal(Kir); out(c, Kir)) |
      (event Reveal(Kri); out(c, Kri)) |
      (event IvReveal(CommonIv); out(c, CommonIv))
  )
