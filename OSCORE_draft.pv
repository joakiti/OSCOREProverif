free c: channel.
free secureChannel:channel[private].
(*******************)
(* Everything COAP *)
(*******************)
type CoAP_request[data].
type CoAP_header[data].
(*CoAP body begin*)
type CoAP_token[data].
type CoAP_options[data].
type CoAP_option[data].
type CoAP_payload[data].
(*CoAP header*)
type CoAP_version[data].
fun CoAP_versionOne(): CoAP_version.
type CoAP_confirmCode[data].
fun CoAP_confirmable(): CoAP_confirmCode.
fun CoAP_nonConfirm(): CoAP_confirmCode.
type CoAP_tokenlength[data].
fun CoAP_tokenLength(CoAP_token): CoAP_tokenlength.
type CoAP_requestCode[data].
fun CoAP_GETCode(): CoAP_requestCode.
fun CoAP_POSTCode(): CoAP_requestCode.
fun CoAP_CHANGEDCode(): CoAP_requestCode.
type CoAP_messageID[data].

fun Header(CoAP_version, CoAP_confirmCode, CoAP_tokenlength, CoAP_requestCode, CoAP_messageID) : CoAP_header[data].
fun Request(CoAP_header, CoAP_token, CoAP_option, CoAP_payload) : CoAP_request[data].
(*******************)
(*    OSCORE       *)
(*******************)

(********************************************)
(* AEAD - Encryption and authenticated data *)
(********************************************)
type oscore_version.
fun oscore_version_one() : oscore_version.
type aead_algorithm.
fun default_aead_algorithm(): aead_algorithm.
type hkdf_algorithm.
fun default_hkdf_algorithm(): hkdf_algorithm.
type hkdf_key_type.
fun key_type() : hkdf_key_type.
fun iv_type() : hkdf_key_type.
type sender_id.
(*We dont model ID context at the time*)
(*We dont model the size of the key nonce for aead algorithm*)
type info.
type nonce.
type additional_data.
(*******************)
(*Security Contexts*)
(*******************)
type security_context.
type common_context.
type sender_context.
type recipient_context.
type master_secret.
type master_salt.
type oscore_key.
type iv.
fun gen_info(sender_id, aead_algorithm, hkdf_key_type) : info.
fun derive_key(master_salt, master_secret, info) : oscore_key.
fun create_common_context(aead_algorithm, hkdf_algorithm, master_secret, master_salt, iv) : common_context.
reduc forall aa:aead_algorithm, dha: hkdf_algorithm, ms: master_secret, mss: master_salt, initv: iv; destructCOMMON_CONTEXT(create_common_context(aa, dha,ms, mss, initv)) = (aa, dha,ms, mss, initv).
fun create_security_context(common_context, sender_context, recipient_context): security_context.
reduc forall cc:common_context, sc:sender_context, rc:recipient_context; destructSECURITY_CONTEXT(create_security_context(cc,sc,rc)) = (cc,sc,rc).
type sender_sequence_number.
fun CoAP_OSCORE_Option(sender_sequence_number, sender_id) : CoAP_option.
reduc forall partiv: sender_sequence_number, sendid: sender_id; destructOSCORE_OPTION(CoAP_OSCORE_Option(partiv, sendid)) = (partiv, sendid).
fun CoAP_EmptyOption(): CoAP_option.
fun partial_iv(sender_sequence_number): iv.

fun getSenderContext(sender_id) : sender_context.
fun getSenderKey(sender_context) : oscore_key.

(*AAD with CoAP Option*)
fun AADwOption(oscore_version, aead_algorithm, sender_id, iv, CoAP_option) : additional_data.
(*AAD with no integrity protected options*)
fun AAD(oscore_version, aead_algorithm, sender_id, iv) : additional_data.
fun aead_nonce(sender_id, iv, sender_sequence_number) : nonce.
(*********************************************)
(*                    COSE                   *)
(*********************************************)
(* No model of the protected data - it's always empty*)
(* IV and Sender_ID are contained in the unprotected field*)
(* COSE_ciphertext is the ciphertext field*)
event here.
query event(here).
(*CHANGE THIS TO BE MORE GENERIC*)
free common_iv:iv[private].
free sid:sender_id[private].
fun sender_key (sender_id):oscore_key[private].
free senderkey : oscore_key[private].
(*WRONG RECIPIENT KEY FUNCTION. TODO: Change to sender idÂ½*)
fun recipient_key(oscore_key):oscore_key.
free agreed_sender_sequence_number:sender_sequence_number[private].
(* Not this*)
type COSE_ciphertext.
fun enc_COSE_ciphertext(oscore_key, nonce, bitstring, additional_data): COSE_ciphertext.
fun payload_from_ciphertext(COSE_ciphertext):CoAP_payload[data].
reduc forall k:oscore_key, n:nonce, plain: bitstring, add:additional_data;
  dec_COSE_ciphertext(enc_COSE_ciphertext(k,n,plain,add), k, n, add) = plain.
reduc forall k:oscore_key, n:nonce, plain: bitstring, add:additional_data;
  dec_COSE_ciphertext_no_ad(enc_COSE_ciphertext(k,n,plain,add), k, n) = plain.
reduc forall k:oscore_key, n:nonce, plain: bitstring, add:additional_data;
  dec_COSE_ciphertext_recipient(enc_COSE_ciphertext(k,n,plain,add), recipient_key(k), n, add) = plain.

fun COSE(sender_sequence_number, sender_id, COSE_ciphertext): COSE[data].

let request_sender =
  new token : CoAP_token;
(*HEADER*)
  let version = CoAP_versionOne() in
  let confirm = CoAP_nonConfirm() in
  let tlength = CoAP_tokenLength(token) in
  let rcode = CoAP_POSTCode() in
  new messageID : CoAP_messageID;
  let header = Header(version, confirm, tlength, rcode, messageID) in
(*HEADER END*)
(*BODY*)
  new payload : CoAP_payload;
(*BODY*)
(*Assemble request and send*)
  let request = Request(header, token, CoAP_EmptyOption(), payload) in
  out(secureChannel, request).

let oscore_princial =
  in(secureChannel, req: CoAP_request);
  (*Decode the received message from "(D)TLS" *)
  let Request(reqheader, token, option, payload) = req in
  let Header(version, confirmCode, tlength, requestCode, messageId) = reqheader in
  (*Generate additation authenticated data. No options that should be integrity protected for now*)
  let aad = AAD(oscore_version_one(), default_aead_algorithm(), sid, partial_iv(agreed_sender_sequence_number)) in
  (*Plaintext is equivalent to a CoAP message without header. *)
  (*It consists of the data to be encrypted, e.g the Request Code, the class E options, and the payload of the original CoAP message*)
  let secret_plaintext = (requestCode, payload) in (*This early draft assumes no Class E option*)
  (*We compute the AEAD nonce from sender_id, common_iv, and the partial iv(which is apparently just the sender sequence number)*)
  (*TODO: remove agreed sender sequence number with generic*)
  (*TODO: remove senderid  number with generic*)
  (*TODO: remove common_iv number with generic*)
  let aeadnonce = aead_nonce(sid, common_iv, agreed_sender_sequence_number) in
  (*The ciphertext of the COSE object is constructed using the sender key, an aead nonce, the plaintext, and the aad*)
  let ciphertext = enc_COSE_ciphertext(senderkey, aeadnonce, secret_plaintext, aad) in
  (*We create the COSE object, where the protected field is empty, unprotected is the partial iv, and sid. The ciphertext *)
  let COSEobject = COSE(agreed_sender_sequence_number, sid, ciphertext) in
  (*Why do we create an object and then destruct it? Well, COSE is supposed to be compressed *)
  (*and this is how its done in the protocol*)
  (*it might not make sense to do it like this in ProVerif*)
  let (partialiv:sender_sequence_number, kid: sender_id) = getUnprotected(COSEobject) in
  let ciphertex : COSE_ciphertext = getCiphertext(COSEobject) in
  (*The oscore option contains a compressed COSE object with it's unprotected fields*)
  let OSCORE_OPTION = CoAP_OSCORE_Option(partialiv,kid) in
  (*The oscore request should contain a dummy code*)
  let dummyCode = CoAP_GETCode() in
  (*We are ready to send an OSCORE request*)
  (*The payload from the original CoAP message is encrypted in COSE and then added as payload*)
  let header = Header(version, confirmCode, tlength, dummyCode, messageId) in
  let request = Request(header, token, OSCORE_OPTION, payload_from_ciphertext(ciphertex)) in
  out(c, request).

let oscore_recipient =
  in(c, req:CoAP_request);
  let Request(reqheader, token, option, payload) = req in
  let Header(version, confirmCode, tlength, requestCode, messageId) = reqheader in
  (*
  Discard all class E options (If a option that should be encrypted is visible in the header, we instead discard
  N.B we don't have any class E at this point in time TODO: Implement class E.
  *)
  (*Using kid parameter to receive a recipient context:*)
  let (partialiv:sender_sequence_number, kid: sender_id) = destructOSCORE_OPTION(option) in
  let rec_key = recipient_key(senderkey) in
  (*- Check Partial IV is unique.. TODO: implement*)
  let ciphertext = ciphertext_from_payload(payload) in
  (*Decompress the COSE Object. TODO: Implement decompression?*)
  (*Compose AAD*)
  let aad = AAD(oscore_version_one(), default_aead_algorithm(), kid, partial_iv(partialiv)) in
  (*Compute the AEAD Nonce*)
  let aeadnonce = aead_nonce(sid, common_iv, agreed_sender_sequence_number) in
  (*Decrypt the COSE object*)
  let decrypted_plaintext = dec_COSE_ciphertext_recipient(ciphertext, rec_key, aeadnonce, aad) in
  (*TODO: Verify the options, etc.*)
  event here;
  out(c, ciphertext);
  0.
query attacker(new payload).


process
  new masterSecret : master_secret; new masterSalt : master_salt; new commoniv : iv;
  let commoncontext = create_common_context(default_aead_algorithm(), default_hkdf_algorithm, masterSecret, masterSalt, common_iv) in


  (!request_sender) | (!oscore_recipient)
