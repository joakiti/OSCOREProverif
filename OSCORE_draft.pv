free c: channel.

(*CoAP*)
type CoAP_Message[data].
type CoAP_header[data].
type CoAP_token[data].
type CoAP_options[data].
type CoAP_option[data].
type CoAP_payload[data].
type CoAP_version[data].
fun CoAP_versionOne(): CoAP_version.
type CoAP_confirmCode[data].
fun CoAP_confirmable(): CoAP_confirmCode.
fun CoAP_nonConfirm(): CoAP_confirmCode.
type CoAP_tokenlength[data].
fun CoAP_tokenLength(CoAP_token): CoAP_tokenlength.
type CoAP_MessageCode[data].
type CoAP_messageID[data].

(*Cryptographic elements*)
type id. (* Initiator / Responder ID, aka. KID *)
type key. (* Initiator / Responder key*)
type nonce. (* AEAD Nonce *)
type additional_data. (* Additional data for AEAD *)
type iv. (*Common IV or Partial IV*)
type master_secret.
type aead_algorithm.
type oscore_version.
type COSE_ciphertext.



fun derive_key(master_secret, id, aead_algorithm): key.
fun derive_common_iv(master_secret, aead_algorithm): iv.
(*Options*)
fun CoAP_Option_OSCORE_Option(iv, id) : CoAP_option[data].
fun CoAP_Option_OSCORE_Option_empty() : CoAP_option[data].
fun CoAP_EmptyOption(): CoAP_option.

(*Codes*)
fun CoAP_GETCode(): CoAP_MessageCode.
fun CoAP_POSTCode(): CoAP_MessageCode.
fun CoAP_CHANGEDCode(): CoAP_MessageCode.

(*Constructors*)
fun Header(CoAP_version, CoAP_confirmCode, CoAP_tokenlength, CoAP_MessageCode, CoAP_messageID) : CoAP_header[data].
fun Request(CoAP_header, CoAP_token, CoAP_option, CoAP_payload) : CoAP_Message[data].

(* Default options. TODO: Delete? *)
fun oscore_version_one() : oscore_version.
fun default_aead_algorithm(): aead_algorithm.


fun AAD(oscore_version, aead_algorithm, id, iv) : additional_data[data].
(*Sender ID, CommonIV, PartialIV*)
fun aead_nonce(id, iv, iv) : nonce.

event Reveal(key).
event IvReveal(iv).
event PartialIvReplay(iv).
event here.
event respondFinish(iv).
event partialIvAccepted(iv).
event beginAparam(id).
event endAparam(id).
event beginBparam(id).
event endBparam(id).

(* Not this*)
type COSEObject.
fun enc_COSE_ciphertext(key, nonce, bitstring, additional_data): COSE_ciphertext.
fun payload_from_ciphertext(COSE_ciphertext):CoAP_payload[data].
fun generateResponsePayload(CoAP_MessageCode, CoAP_payload): CoAP_payload.
fun generateResponseCode(CoAP_MessageCode, CoAP_payload): CoAP_MessageCode.

(*
The ID Context, Sender ID, and Partial IV are always at least
implicitly integrity protected, as manipulation leads to the wrong
nonce or key being used and therefore results in decryption failure.

E.g i dont think we can have the no_ad function
*)
reduc forall k:key, n:nonce, plain: bitstring, add:additional_data;
  dec_COSE_ciphertext(enc_COSE_ciphertext(k,n,plain,add), k, n, add) = plain.
reduc forall k:key, n:nonce, plain: bitstring, add:additional_data;
  dec_COSE_ciphertext_no_ad(enc_COSE_ciphertext(k,n,plain,add), k, n) = plain.


table security_context_lookup(id, id, master_secret).
table context(key, id, key, id, iv).
table unique_ivs(iv).

fun COSE(iv, id, COSE_ciphertext): COSEObject[data].

let oscore_initiator(IDir: id) =
  in(c, IDri: id); (*Receive our endpoint from somewhere*)
  event beginBparam(IDri); (*Begin event that some host has been accepted, possibly B.*)
  get security_context_lookup(=IDir, =IDri, msecret:master_secret) in (*Find a security context with endpoint*)
  let CommonIv = derive_common_iv(msecret, default_aead_algorithm()) in
  let Kir = derive_key(msecret, IDir, default_aead_algorithm()) in
  let Kri = derive_key(msecret, IDri, default_aead_algorithm()) in
  new token : CoAP_token;
  new partial_iv: iv;
  let version = CoAP_versionOne() in
  let confirm = CoAP_nonConfirm() in
  let tlength = CoAP_tokenLength(token) in
  let rcode = CoAP_POSTCode() in
  new messageID : CoAP_messageID;
  new payload : CoAP_payload;
  let aad = AAD(oscore_version_one(), default_aead_algorithm(), IDir, partial_iv) in
  let secret_plaintext = (rcode, payload) in (*This early draft assumes no Class E option*)
  (*We compute the AEAD nonce from sender_id, common_iv, and the partial iv(which is apparently just the sender sequence number)*)
  let aeadnonce = aead_nonce(IDir, CommonIv, partial_iv) in
  (*The ciphertext of the COSE object is constructed using the sender key, an aead nonce, the plaintext, and the aad*)
  let ciphertext = enc_COSE_ciphertext(Kir, aeadnonce, secret_plaintext, aad) in
  let COSEobject = COSE(partial_iv, IDir, ciphertext) in
  (*it might not make sense to do it like this in ProVerif*)
  (*The oscore option contains a compressed COSE object with it's unprotected fields*)
  let OSCORE_OPTION = CoAP_Option_OSCORE_Option(partial_iv, IDir) in
  (*The oscore request should contain a dummy code*)
  let dummyCode = CoAP_GETCode() in
  (*The payload from the original CoAP message is encrypted in COSE and then added as payload*)
  let header = Header(version, confirm, tlength, dummyCode, messageID) in
  let request = Request(header, token, OSCORE_OPTION, payload_from_ciphertext(ciphertext)) in
  out(c, request);
  (*Receive a response*)
  in(c, response:CoAP_Message);
  let Request(resheader, restoken, resoption, respayload) = response in
  let Header(resversion, resconfirmCode, restlength, resrequestCode, resmessageId) = resheader in
  if restoken = token then (*Bind response to request*)
  (*In a piggybacked response, the Message ID of the Confirmable
       request and the Acknowledgement MUST match, and the tokens of the
       response and original request MUST match.
      ---> In a separate response, just the tokens of the response and original request MUST match. <---
       *)
  if resoption = CoAP_Option_OSCORE_Option_empty() then
  let responseAad = AAD(oscore_version_one(), default_aead_algorithm(), IDri, partial_iv) in
  let payload_from_ciphertext(p) = respayload in
  let (rescode : CoAP_MessageCode, decryptedPayload : CoAP_payload) = dec_COSE_ciphertext(p, Kri, aeadnonce, responseAad) in
  event endAparam(IDir);
  event here;
  0.

let oscore_responder(IDri: id) =
  (************************)
  (*  Verifying request   *)
  (************************)
  in(c, req:CoAP_Message);
  let Request(reqheader, token, option, payload) = req in
  let Header(version, confirmCode, tlength, requestCode, messageId) = reqheader in
  let CoAP_Option_OSCORE_Option(partial_iv, kid) = option in
  event beginAparam(kid); (*Event that protocol started in processB *)
  let payload_from_ciphertext(p) = payload in
  (*Decompress the COSE Object. TODO: Implement decompression?*)
  (*KEY + COMMON_IV*)
  get security_context_lookup(=kid, =IDri, msecret:master_secret) in
  let CommonIv = derive_common_iv(msecret, default_aead_algorithm()) in
  let Kir = derive_key(msecret, kid, default_aead_algorithm()) in
  let Kri = derive_key(msecret, IDri, default_aead_algorithm()) in
  (*Compose AAD*)
  let aad = AAD(oscore_version_one(), default_aead_algorithm(), kid, partial_iv) in
  (*Compute the AEAD Nonce*)
  let aeadnonce = aead_nonce(kid, CommonIv, partial_iv) in
  (*Decrypt the COSE object*)
  let (rcode : CoAP_MessageCode, decryptedPayload : CoAP_payload) = dec_COSE_ciphertext(p, Kir, aeadnonce, aad) in
  (*If we get the same we execute partialreplay event, otherwise, we continue.*)
  get unique_ivs(partial:iv) suchthat partial = partial_iv in event PartialIvReplay(partial_iv) else
  event partialIvAccepted(partial_iv);
  (*keep track of used unique_ivs*)
  insert unique_ivs(partial_iv);

  (*************************)
  (*  Response Generation  *)
  (*************************)
  let responsePayload = generateResponsePayload(rcode, decryptedPayload) in
  let responseCode = generateResponseCode(rcode, decryptedPayload) in
  let response_secret_plaintext = (responseCode, responsePayload) in (*This early draft assumes no Class E option*)
  let responseAad = AAD(oscore_version_one(), default_aead_algorithm(), IDri, partial_iv) in
  let ciphertext = enc_COSE_ciphertext(Kri, aeadnonce, response_secret_plaintext, responseAad) in
  let COSEobject = COSE(partial_iv, IDri, ciphertext) in
  (*We use the AEAD nonce from the request.*)
  let responseDummyCode = CoAP_CHANGEDCode() in
  let OSCORE_OPTION = CoAP_Option_OSCORE_Option_empty() in
  new responseMessageId : CoAP_messageID;
  let header = Header(CoAP_versionOne(),  CoAP_nonConfirm(), CoAP_tokenLength(token), responseDummyCode, responseMessageId) in
  let request = Request(header, token, OSCORE_OPTION, payload_from_ciphertext(ciphertext)) in
  event endBparam(IDri);
  out(c, request).

query Kir:key; attacker(new payload) ==> event (Reveal(Kir)).
query CommonIv:iv; attacker(new payload) ==> event (IvReveal(CommonIv)).
query x: id, CommonIv:iv, Kir:key; event(endBparam(x)) ==> (event(beginBparam(x)) || event(IvReveal(CommonIv)) || event(Reveal(Kir))).
query x: id, CommonIv:iv, Kir:key; event(endAparam(x)) ==> (event(beginAparam(x)) || event(IvReveal(CommonIv)) || event(Reveal(Kir))).

(*This query is acting weird, ask Alessandro:*)
(*Got it working, but still.. is it sound?*)
query partialiv:iv; event (PartialIvReplay(partialiv)) ==> event(partialIvAccepted(partialiv)).

query event(here).

let init(idA:id,idB:id) =
  in(c, (Kir: key, IDir:id, Kri: key, IDri:id, MasterSecret : master_secret));
  if IDir <> idA && IDri <> idB then insert security_context_lookup(IDir, IDri, MasterSecret).

process
  new IDir:id; new IDri:id; new MasterSecret : master_secret;
  let CommonIv = derive_common_iv(MasterSecret, default_aead_algorithm()) in
  let Kir = derive_key(MasterSecret, IDir, default_aead_algorithm()) in
  let Kri = derive_key(MasterSecret, IDri, default_aead_algorithm()) in
  out(c, (IDir, IDri));
  insert security_context_lookup(IDir, IDri, MasterSecret);
  (!oscore_initiator(IDir)) | (!oscore_responder(IDri)) | (!init(IDir,IDri)) |   (
        (event Reveal(Kir); out(c, Kir)) |
        (event Reveal(Kri); out(c, Kri)) |
        (event IvReveal(CommonIv); out(c, CommonIv))
    )
