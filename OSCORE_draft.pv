free c: channel.
(*******************)
(* Everything COAP *)
(*******************)
type CoAP_Message[data].
type CoAP_header[data].
(*CoAP body begin*)
type CoAP_token[data].
type CoAP_options[data].
type CoAP_option[data].
type CoAP_payload[data].
(*CoAP header*)
type CoAP_version[data].
fun CoAP_versionOne(): CoAP_version.
type CoAP_confirmCode[data].
fun CoAP_confirmable(): CoAP_confirmCode.
fun CoAP_nonConfirm(): CoAP_confirmCode.
type CoAP_tokenlength[data].
fun CoAP_tokenLength(CoAP_token): CoAP_tokenlength.
type CoAP_MessageCode[data].
fun CoAP_GETCode(): CoAP_MessageCode.
fun CoAP_POSTCode(): CoAP_MessageCode.
fun CoAP_CHANGEDCode(): CoAP_MessageCode.
type CoAP_messageID[data].

fun Header(CoAP_version, CoAP_confirmCode, CoAP_tokenlength, CoAP_MessageCode, CoAP_messageID) : CoAP_header[data].
fun Request(CoAP_header, CoAP_token, CoAP_option, CoAP_payload) : CoAP_Message[data].
(*******************)
(*    OSCORE       *)
(*******************)
type oscore_version.
fun oscore_version_one() : oscore_version.
type aead_algorithm.
fun default_aead_algorithm(): aead_algorithm.
type hkdf_algorithm.
fun default_hkdf_algorithm(): hkdf_algorithm.
type hkdf_key_type.
fun key_type() : hkdf_key_type.
fun iv_type() : hkdf_key_type.
type id.
(*We dont model ID context at the time*)
(*We dont model the size of the key nonce for aead algorithm*)
type info.
type nonce.
type additional_data.
(*******************)
(*Security Contexts*)
(*******************)
type master_secret.
type master_salt.
type key.
type iv.
type sender_sequence_number.
fun CoAP_Option_OSCORE_Option(iv, id) : CoAP_option[data].
fun CoAP_Option_OSCORE_Option_empty() : CoAP_option[data].

fun CoAP_EmptyOption(): CoAP_option.
(*AAD with no integrity protected options*)
fun AAD(oscore_version, aead_algorithm, id, iv) : additional_data[data].
fun aead_nonce(id, iv, iv) : nonce.
(*********************************************)
(*                    COSE                   *)
(*********************************************)
(* No model of the protected data - it's always empty*)
(* IV and Sender_ID are contained in the unprotected field*)
(* COSE_ciphertext is the ciphertext field*)

event Reveal(key).
event IvReveal(iv).
event here.
query event(here).
(* Not this*)
type COSEObject.
type COSE_ciphertext.
fun enc_COSE_ciphertext(key, nonce, bitstring, additional_data): COSE_ciphertext.
fun payload_from_ciphertext(COSE_ciphertext):CoAP_payload[data].
fun generateResponsePayload(CoAP_MessageCode, CoAP_payload): CoAP_payload.
fun generateResponseCode(CoAP_MessageCode, CoAP_payload): CoAP_MessageCode.

(*
The ID Context, Sender ID, and Partial IV are always at least
implicitly integrity protected, as manipulation leads to the wrong
nonce or key being used and therefore results in decryption failure.

E.g i dont think we can have the no_ad function
*)
reduc forall k:key, n:nonce, plain: bitstring, add:additional_data;
  dec_COSE_ciphertext(enc_COSE_ciphertext(k,n,plain,add), k, n, add) = plain.
reduc forall k:key, n:nonce, plain: bitstring, add:additional_data;
  dec_COSE_ciphertext_no_ad(enc_COSE_ciphertext(k,n,plain,add), k, n) = plain.


table context(key, id, key, id, iv).

fun COSE(iv, id, COSE_ciphertext): COSEObject[data].

let oscore_initiator =
  get context(Kir:key, IDir:id, Kri:key, IDri: id, CommonIv:iv) in
  new token : CoAP_token;
  new partial_iv: iv;
  (*HEADER*)
  let version = CoAP_versionOne() in
  let confirm = CoAP_nonConfirm() in
  let tlength = CoAP_tokenLength(token) in
  let rcode = CoAP_POSTCode() in
  new messageID : CoAP_messageID;
  (*HEADER END*)
  (*BODY*)
  new payload : CoAP_payload;
  (*BODY*)
  (*Assemble request and send*)
  (*Generate additation authenticated data. No options that should be integrity protected for now*)
  let aad = AAD(oscore_version_one(), default_aead_algorithm(), IDir, partial_iv) in
  (*Plaintext is equivalent to a CoAP message without header. *)
  (*It consists of the data to be encrypted, e.g the Request Code, the class E options, and the payload of the original CoAP message*)
  let secret_plaintext = (rcode, payload) in (*This early draft assumes no Class E option*)
  (*We compute the AEAD nonce from sender_id, common_iv, and the partial iv(which is apparently just the sender sequence number)*)
  let aeadnonce = aead_nonce(IDir, CommonIv, partial_iv) in
  (*The ciphertext of the COSE object is constructed using the sender key, an aead nonce, the plaintext, and the aad*)
  let ciphertext = enc_COSE_ciphertext(Kir, aeadnonce, secret_plaintext, aad) in
  (*We create the COSE object, where the protected field is empty, unprotected is the partial iv, and sid. The ciphertext *)
  let COSEobject = COSE(partial_iv, IDir, ciphertext) in
  (*Why do we create an object and then destruct it? Well, COSE is supposed to be compressed *)
  (*and this is how its done in the protocol*)
  (*it might not make sense to do it like this in ProVerif*)
  let COSE(partialiv, kid, ciphertex) = COSEobject in
  (*The oscore option contains a compressed COSE object with it's unprotected fields*)
  let OSCORE_OPTION = CoAP_Option_OSCORE_Option(partial_iv,kid) in
  (*The oscore request should contain a dummy code*)
  let dummyCode = CoAP_GETCode() in
  (*We are ready to send an OSCORE request*)
  (*The payload from the original CoAP message is encrypted in COSE and then added as payload*)
  let header = Header(version, confirm, tlength, dummyCode, messageID) in
  let request = Request(header, token, OSCORE_OPTION, payload_from_ciphertext(ciphertex)) in
  out(c, request);

  (*Receive a response*)
  in(c, response:CoAP_Message);

  let Request(resheader, restoken, resoption, respayload) = response in
  let Header(resversion, resconfirmCode, restlength, resrequestCode, resmessageId) = resheader in
  if restoken = token then
  if resoption = CoAP_Option_OSCORE_Option_empty() then
  let aad = AAD(oscore_version_one(), default_aead_algorithm(), IDri, partial_iv) in
  let payload_from_ciphertext(p) = respayload in
  let (rcode : CoAP_MessageCode, decryptedPayload : CoAP_payload) = dec_COSE_ciphertext(p, Kri, aeadnonce, aad) in
  (*Computing the AEAD nonce.. We know that the oscore option is empty so we use old nonce*)
  event here;
  0.

let oscore_responder =
  (************************)
  (*  Verifying request   *)
  (************************)
  in(c, req:CoAP_Message);
  get context(Kir:key, IDir:id, Kri:key, IDri: id, CommonIv:iv) in
  let Request(reqheader, token, option, payload) = req in
  let Header(version, confirmCode, tlength, requestCode, messageId) = reqheader in
  (*
  Discard all class E options (If a option that should be encrypted is visible in the header, we instead discard
  N.B we don't have any class E at this point in time TODO: Implement class E.
  *)
  (*Using kid parameter to receive a recipient context:*)
  let CoAP_Option_OSCORE_Option(partial_iv, kid) = option in
  (*- Check Partial IV is unique.. TODO: implement*)
  let payload_from_ciphertext(p) = payload in
  (*Decompress the COSE Object. TODO: Implement decompression?*)
  (*Compose AAD*)
  let aad = AAD(oscore_version_one(), default_aead_algorithm(), kid, partial_iv) in
  (*Compute the AEAD Nonce*)
  let aeadnonce = aead_nonce(kid, CommonIv, partial_iv) in
  (*Decrypt the COSE object*)
  let (rcode : CoAP_MessageCode, decryptedPayload : CoAP_payload) = dec_COSE_ciphertext(p, Kir, aeadnonce, aad) in
  (*************************)
  (*  Response Generation  *)
  (*************************)
  let responsePayload = generateResponsePayload(rcode, decryptedPayload) in
  let responseCode = generateResponseCode(rcode, decryptedPayload) in
  let response_secret_plaintext = (responseCode, responsePayload) in (*This early draft assumes no Class E option*)
  let responseAad = AAD(oscore_version_one(), default_aead_algorithm(), IDri, partial_iv) in
  (*We use the AEAD nonce from the request.*)
  let ciphertext = enc_COSE_ciphertext(Kri, aeadnonce, response_secret_plaintext, responseAad) in
  let COSEobject = COSE(partial_iv, IDri, ciphertext) in
  let responseDummyCode = CoAP_CHANGEDCode() in
  let OSCORE_OPTION = CoAP_Option_OSCORE_Option_empty() in
  new responseMessageId : CoAP_messageID;
  let header = Header(CoAP_versionOne(),  CoAP_nonConfirm(), CoAP_tokenLength(token), responseDummyCode, responseMessageId) in
  let request = Request(header, token, OSCORE_OPTION, payload_from_ciphertext(ciphertext)) in
  out(c, request);
  0.

query Kir:key; attacker(new payload) ==> event (Reveal(Kir)).
query CommonIv:iv; attacker(new payload) ==> event (IvReveal(CommonIv)).

let init =
  new Kir: key; new IDir:id; new Kri: key; new IDri:id; new CommonIv:iv;
  insert context(Kir, IDir, Kri, IDri, CommonIv);
  (
      (event Reveal(Kir); out(c, Kir)) |
      (event Reveal(Kri); out(c, Kri)) |
      (event IvReveal(CommonIv); out(c, CommonIv))
  ).

process
  (!oscore_initiator) | (!oscore_responder) | (!init)
