free c: channel.
free secureChannel:channel[private].
(*******************)
(* Everything COAP *)
(*******************)
type CoAP_request[data].
type CoAP_header[data].

type CoAP_version[data].
fun CoAP_versionOne(): CoAP_version.
type CoAP_confirmCode[data].
fun CoAP_confirmable(): CoAP_confirmCode.
fun CoAP_nonConfirm(): CoAP_confirmCode.
type CoAP_tokenlength[data].
fun CoAP_expectedLength(): CoAP_tokenlength.
type CoAP_requestCode[data].
fun CoAP_GETCode(): CoAP_requestCode.
fun CoAP_POSTCode(): CoAP_requestCode.
fun CoAP_CHANGEDCode(): CoAP_requestCode.
type CoAP_messageID[data].

(*CoAP body begin*)
type CoAP_token[data].
type CoAP_options[data].
type CoAP_option[data].
type CoAP_payload[data].
fun payload_fromId(CoAP_messageID) : CoAP_payload.
fun createHeader(CoAP_version, CoAP_confirmCode, CoAP_tokenlength, CoAP_requestCode, CoAP_messageID) : CoAP_header[data].
reduc forall cv:CoAP_version, cc:CoAP_confirmCode, ctl:CoAP_tokenlength, crc:CoAP_requestCode, cmid:CoAP_messageID; destructH(createHeader(cv,cc,ctl,crc,cmid)) = (cv,cc,ctl,crc,cmid).
fun createRequest(CoAP_header, CoAP_token, CoAP_option, CoAP_payload) : CoAP_request[data].
reduc forall ch: CoAP_header, ct:CoAP_token, co:CoAP_option, cp:CoAP_payload; destructR(createRequest(ch,ct,co,cp)) = (ch,ct,co,cp).
(*******************)
(*    OSCORE       *)
(*******************)

(*******************)
(*Security Contexts*)
(*******************)
type sender_sequence_number.
type sender_context.
type sender_id.
fun CoAP_OSCORE_Option(sender_sequence_number, sender_id) : CoAP_option.
reduc forall partiv: sender_sequence_number, sendid: sender_id; destructOSCORE_OPTION(CoAP_OSCORE_Option(partiv, sendid)) = (partiv, sendid).
fun CoAP_EmptyOption(): CoAP_option.
type iv.
fun partial_iv(sender_sequence_number): iv.
type oscore_key.

fun getSenderContext(sender_id) : sender_context.
fun getSenderKey(sender_context) : oscore_key.

(********************************************)
(* AEAD - Encryption and authenticated data *)
(********************************************)
type oscore_version.
fun oscore_version_one() : oscore_version.
type aead_algorithm.
fun default_aead_algorithm(): aead_algorithm.
type nonce.

type additional_data.
(*AAD with CoAP Option*)
fun AADwOption(oscore_version, aead_algorithm, sender_id, iv, CoAP_option) : additional_data.
(*AAD with no integrity protected options*)
fun AAD(oscore_version, aead_algorithm, sender_id, iv) : additional_data.
fun aead_nonce(sender_id, iv, sender_sequence_number) : nonce.
type ptext.
fun plaintext(CoAP_requestCode, CoAP_payload) : ptext.
(*********************************************)
(*                    COSE                   *)
(*********************************************)

(* No model of the protected data - it's always empty*)
(* IV and Sender_ID are contained in the unprotected field*)
(* COSE_ciphertext is the ciphertext field*)


event here.
query event(here).


(*CHANGE THIS TO BE MORE GENERIC*)
free common_iv:iv[private].
free sid:sender_id[private].
fun sender_key (sender_id):oscore_key[private].
free senderkey : oscore_key[private].
(*WRONG RECIPIENT KEY FUNCTION. TODO: Change to sender idÂ½*)
fun recipient_key(oscore_key):oscore_key.
free agreed_sender_sequence_number:sender_sequence_number[private].
(* Not this*)
type COSE.
type COSE_ciphertext.
fun enc_COSE_ciphertext(oscore_key, nonce, ptext, additional_data): COSE_ciphertext.
fun payload_from_ciphertext(COSE_ciphertext):CoAP_payload.
reduc forall x:COSE_ciphertext; ciphertext_from_payload(payload_from_ciphertext(x)) = x.
reduc forall k:oscore_key, n:nonce, plain: ptext, add:additional_data; dec_COSE_ciphertext(enc_COSE_ciphertext(k,n,plain,add), k, n, add) = plain.
reduc forall k:oscore_key, n:nonce, plain: ptext, add:additional_data; dec_COSE_ciphertext_recipient(enc_COSE_ciphertext(k,n,plain,add), recipient_key(k), n, add) = plain.

fun createCOSE(sender_sequence_number, sender_id, COSE_ciphertext) : COSE.
reduc forall partialiv: sender_sequence_number, kid:sender_id, ciphertex: COSE_ciphertext; getUnprotected(createCOSE(partialiv,kid,ciphertex)) = (partialiv,kid).
reduc forall partialiv: sender_sequence_number, kid:sender_id, ciphertex: COSE_ciphertext; getCiphertext(createCOSE(partialiv,kid,ciphertex)) = ciphertex.

let request_sender =
(*HEADER*)
  let version = CoAP_versionOne() in
  let confirm = CoAP_nonConfirm() in
  let tlength = CoAP_expectedLength() in
  let rcode = CoAP_POSTCode() in
  new messageID : CoAP_messageID;
  let header = createHeader(version, confirm, tlength, rcode, messageID) in
(*HEADER END*)
(*BODY*)
  new token : CoAP_token;

  new payload : CoAP_payload;
(*BODY*)
(*Assemble request and send*)
  let request = createRequest(header, token, CoAP_EmptyOption(), payload) in
  out(secureChannel, request).

let oscore_princial =
  in(secureChannel, req: CoAP_request);
  (*Decode the received message from "TLS" *)
  let (reqheader:CoAP_header, token:CoAP_token, option:CoAP_option, payload:CoAP_payload) = destructR(req) in
  let (version:CoAP_version, confirmCode: CoAP_confirmCode, tlength: CoAP_tokenlength, requestCode: CoAP_requestCode, messageId: CoAP_messageID) = destructH(reqheader) in

  (*Generate additation authenticated data. No options that should be integrity protected for now*)
  let aad = AAD(oscore_version_one(), default_aead_algorithm(), sid, partial_iv(agreed_sender_sequence_number)) in

  (*Plaintext is equivalent to a CoAP message without header. *)
  (*It consists of the data to be encrypted, e.g the Request Code, the class E options, and the payload of the original CoAP message*)
  let secret_plaintext = plaintext(requestCode, payload) in (*This early draft assumes no Class E option*)

  (*We compute the AEAD nonce from sender_id, common_iv, and the partial iv(which is apparently just the sender sequence number)*)
  (*TODO: remove agreed sender sequence number with generic*)
  (*TODO: remove senderid  number with generic*)
  (*TODO: remove common_iv number with generic*)
  let aeadnonce = aead_nonce(sid, common_iv, agreed_sender_sequence_number) in

  (*The ciphertext of the COSE object is constructed using the sender key, an aead nonce, the plaintext, and the aad*)
  let ciphertext = enc_COSE_ciphertext(senderkey, aeadnonce, secret_plaintext, aad) in

  (*We create the COSE object, where the protected field is empty, unprotected is the partial iv, and sid. The ciphertext *)
  let COSEobject = createCOSE(agreed_sender_sequence_number, sid, ciphertext) in
  (*Why do we create an object and then destruct it? Well, COSE is supposed to be compressed *)
  (*and this is how its done in the protocol*)
  (*it might not make sense to do it like this in ProVerif*)
  let (partialiv:sender_sequence_number, kid: sender_id) = getUnprotected(COSEobject) in
  let ciphertex : COSE_ciphertext = getCiphertext(COSEobject) in
  (*The oscore option contains a compressed COSE object with it's unprotected fields*)
  let OSCORE_OPTION = CoAP_OSCORE_Option(partialiv,kid) in
  (*The oscore request should contain a dummy code*)
  let dummyCode = CoAP_GETCode() in
  (*We are ready to send an OSCORE request*)
  (*The payload from the original CoAP message is encrypted in COSE and then added as payload*)
  let header = createHeader(version, confirmCode, tlength, dummyCode, messageId) in
  let request = createRequest(header, token, OSCORE_OPTION, payload_from_ciphertext(ciphertex)) in
  out(c, request).

let oscore_recipient =
  in(c, req:CoAP_request);
  let (reqheader:CoAP_header, token:CoAP_token, option:CoAP_option, payload:CoAP_payload) = destructR(req) in
  let (version:CoAP_version, confirmCode: CoAP_confirmCode, tlength: CoAP_tokenlength, requestCode: CoAP_requestCode, messageId: CoAP_messageID) = destructH(reqheader) in
  (*
  Discard all class E options (If a option that should be encrypted is visible in the header, we instead discard
  N.B we don't have any class E at this point in time TODO: Implement class E.
  *)
  (*Using kid parameter to receive a recipient context:*)
  let (partialiv:sender_sequence_number, kid: sender_id) = destructOSCORE_OPTION(option) in
  let rec_key = recipient_key(senderkey) in
  (*- Check Partial IV is unique.. TODO: implement*)
  let ciphertext = ciphertext_from_payload(payload) in
  (*Decompress the COSE Object. TODO: Implement decompression?*)
  (*Compose AAD*)
  let aad = AAD(oscore_version_one(), default_aead_algorithm(), kid, partial_iv(partialiv)) in
  (*Compute the AEAD Nonce*)
  let aeadnonce = aead_nonce(sid, common_iv, agreed_sender_sequence_number) in

  (*Decrypt the COSE object*)
  let plaintext = dec_COSE_ciphertext_recipient(ciphertext, rec_key, aeadnonce, aad) in
  event here;
  out(c, ciphertext);

  0.
query attacker (plaintext(CoAP_POSTCode, new payload)).
process
  (!oscore_princial) | (!oscore_princial) | (!request_sender) | (!oscore_recipient)
