free c: channel.

(*CoAP*)
type CoAP_Message[data].
type CoAP_header[data].
type CoAP_token[data].
type CoAP_options[data].
type CoAP_option[data].
type CoAP_payload[data].
type CoAP_version[data].
fun CoAP_versionOne(): CoAP_version.
type CoAP_confirmCode[data].
fun CoAP_confirmable(): CoAP_confirmCode.
fun CoAP_nonConfirm(): CoAP_confirmCode.
type CoAP_tokenlength[data].
fun CoAP_tokenLength(CoAP_token): CoAP_tokenlength.
type CoAP_MessageCode[data].
type CoAP_messageID[data].

(*Cryptographic elements*)
type id. (* Initiator / Responder ID, aka. KID *)
type key. (* Initiator / Responder key*)
type nonce. (* AEAD Nonce *)
type additional_data. (* Additional data for AEAD *)
type iv. (*Common IV or Partial IV*)

(*Options*)
fun CoAP_Option_OSCORE_Option(iv, id) : CoAP_option[data].
fun CoAP_Option_OSCORE_Option_empty() : CoAP_option[data].
fun CoAP_EmptyOption(): CoAP_option.

(*Codes*)
fun CoAP_GETCode(): CoAP_MessageCode.
fun CoAP_POSTCode(): CoAP_MessageCode.
fun CoAP_CHANGEDCode(): CoAP_MessageCode.

(*Constructors*)
fun Header(CoAP_version, CoAP_confirmCode, CoAP_tokenlength, CoAP_MessageCode, CoAP_messageID) : CoAP_header[data].
fun Request(CoAP_header, CoAP_token, CoAP_option, CoAP_payload) : CoAP_Message[data].

(* Default options. TODO: Delete? *)
type oscore_version.
fun oscore_version_one() : oscore_version.
type aead_algorithm.
fun default_aead_algorithm(): aead_algorithm.


fun AAD(oscore_version, aead_algorithm, id, iv) : additional_data[data].
(*Sender ID, CommonIV, PartialIV*)
fun aead_nonce(id, iv, iv) : nonce.

event Reveal(key).
event IvReveal(iv).
event PartialIvReplay(iv).
event here.

query partialiv:iv; event(PartialIvReplay(partialiv)).
(* Not this*)
type COSEObject.
type COSE_ciphertext.
fun enc_COSE_ciphertext(key, nonce, bitstring, additional_data): COSE_ciphertext.
fun payload_from_ciphertext(COSE_ciphertext):CoAP_payload[data].
fun generateResponsePayload(CoAP_MessageCode, CoAP_payload): CoAP_payload.
fun generateResponseCode(CoAP_MessageCode, CoAP_payload): CoAP_MessageCode.

(*
The ID Context, Sender ID, and Partial IV are always at least
implicitly integrity protected, as manipulation leads to the wrong
nonce or key being used and therefore results in decryption failure.

E.g i dont think we can have the no_ad function
*)
reduc forall k:key, n:nonce, plain: bitstring, add:additional_data;
  dec_COSE_ciphertext(enc_COSE_ciphertext(k,n,plain,add), k, n, add) = plain.
reduc forall k:key, n:nonce, plain: bitstring, add:additional_data;
  dec_COSE_ciphertext_no_ad(enc_COSE_ciphertext(k,n,plain,add), k, n) = plain.


table context(key, id, key, id, iv).
table unique_ivs(iv).

fun COSE(iv, id, COSE_ciphertext): COSEObject[data].

let oscore_initiator =
  get context(Kir:key, IDir:id, Kri:key, IDri: id, CommonIv:iv) in

  new token : CoAP_token;
  new partial_iv: iv;
  let version = CoAP_versionOne() in
  let confirm = CoAP_nonConfirm() in
  let tlength = CoAP_tokenLength(token) in
  let rcode = CoAP_POSTCode() in
  new messageID : CoAP_messageID;
  new payload : CoAP_payload;

  let aad = AAD(oscore_version_one(), default_aead_algorithm(), IDir, partial_iv) in

  let secret_plaintext = (rcode, payload) in (*This early draft assumes no Class E option*)

  (*We compute the AEAD nonce from sender_id, common_iv, and the partial iv(which is apparently just the sender sequence number)*)
  let aeadnonce = aead_nonce(IDir, CommonIv, partial_iv) in

  (*The ciphertext of the COSE object is constructed using the sender key, an aead nonce, the plaintext, and the aad*)
  let ciphertext = enc_COSE_ciphertext(Kir, aeadnonce, secret_plaintext, aad) in

  let COSEobject = COSE(partial_iv, IDir, ciphertext) in

  (*it might not make sense to do it like this in ProVerif*)
  let COSE(partialiv, kid, ciphertex) = COSEobject in

  (*The oscore option contains a compressed COSE object with it's unprotected fields*)
  let OSCORE_OPTION = CoAP_Option_OSCORE_Option(partial_iv,kid) in

  (*The oscore request should contain a dummy code*)
  let dummyCode = CoAP_GETCode() in

  (*The payload from the original CoAP message is encrypted in COSE and then added as payload*)
  let header = Header(version, confirm, tlength, dummyCode, messageID) in
  let request = Request(header, token, OSCORE_OPTION, payload_from_ciphertext(ciphertex)) in
  out(c, request);

  (*Receive a response*)
  in(c, response:CoAP_Message);

  let Request(resheader, restoken, resoption, respayload) = response in
  let Header(resversion, resconfirmCode, restlength, resrequestCode, resmessageId) = resheader in
  if restoken = token then (*Bind response to request*)
  if resoption = CoAP_Option_OSCORE_Option_empty() then
  let resaad = AAD(oscore_version_one(), default_aead_algorithm(), IDri, partial_iv) in
  let payload_from_ciphertext(p) = respayload in
  let (rescode : CoAP_MessageCode, decryptedPayload : CoAP_payload) = dec_COSE_ciphertext(p, Kri, aeadnonce, aad) in
  (*Computing the AEAD nonce.. We know that the oscore option is empty so we use old nonce*)
  event here;
  0.

let oscore_responder =
  (************************)
  (*  Verifying request   *)
  (************************)
  in(c, req:CoAP_Message);
  get context(Kir:key, IDir:id, Kri:key, IDri: id, CommonIv:iv) in
  let Request(reqheader, token, option, payload) = req in
  let Header(version, confirmCode, tlength, requestCode, messageId) = reqheader in
  let CoAP_Option_OSCORE_Option(partial_iv, kid) = option in
  (*- Check Partial IV is unique.. TODO: implement*)

  (*If we get the same we execute partialreplay event, otherwise, we continue.*)
  get unique_ivs(partial:iv) suchthat partial = partial_iv in event PartialIvReplay(partial_iv) else
  (*keep track of used unique_ivs*)
  insert unique_ivs(partial_iv);
  let payload_from_ciphertext(p) = payload in
  (*Decompress the COSE Object. TODO: Implement decompression?*)
  (*Compose AAD*)
  let aad = AAD(oscore_version_one(), default_aead_algorithm(), kid, partial_iv) in
  (*Compute the AEAD Nonce*)
  let aeadnonce = aead_nonce(kid, CommonIv, partial_iv) in
  (*Decrypt the COSE object*)
  let (rcode : CoAP_MessageCode, decryptedPayload : CoAP_payload) = dec_COSE_ciphertext(p, Kir, aeadnonce, aad) in
  (*************************)
  (*  Response Generation  *)
  (*************************)
  let responsePayload = generateResponsePayload(rcode, decryptedPayload) in
  let responseCode = generateResponseCode(rcode, decryptedPayload) in
  let response_secret_plaintext = (responseCode, responsePayload) in (*This early draft assumes no Class E option*)
  let responseAad = AAD(oscore_version_one(), default_aead_algorithm(), IDri, partial_iv) in
  (*We use the AEAD nonce from the request.*)
  let ciphertext = enc_COSE_ciphertext(Kri, aeadnonce, response_secret_plaintext, responseAad) in
  let COSEobject = COSE(partial_iv, IDri, ciphertext) in
  let responseDummyCode = CoAP_CHANGEDCode() in
  let OSCORE_OPTION = CoAP_Option_OSCORE_Option_empty() in
  new responseMessageId : CoAP_messageID;
  let header = Header(CoAP_versionOne(),  CoAP_nonConfirm(), CoAP_tokenLength(token), responseDummyCode, responseMessageId) in
  let request = Request(header, token, OSCORE_OPTION, payload_from_ciphertext(ciphertext)) in
  out(c, request);
  0.

query Kir:key; attacker(new payload) ==> event (Reveal(Kir)).
query CommonIv:iv; attacker(new payload) ==> event (IvReveal(CommonIv)).

let init =
  new Kir: key; new IDir:id; new Kri: key; new IDri:id; new CommonIv:iv;
  insert context(Kir, IDir, Kri, IDri, CommonIv);
  (
      (event Reveal(Kir); out(c, Kir)) |
      (event Reveal(Kri); out(c, Kri)) |
      (event IvReveal(CommonIv); out(c, CommonIv))
  ).

process
  (!oscore_initiator) | (!oscore_responder) | (!init)
