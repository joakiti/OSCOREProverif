free c: channel.

type host.
type id.
type key.
type nonce.

const emptyId:id.
const empty:bitstring.

const label_key: bitstring.
const label_iv: bitstring.

(*We imagine a server that can do 2 things, check if a lightbulb is on or off - these are to be considered payloads*)
const isLightBulbTurnedOn : bitstring.
const isLightBulbTurnedOff : bitstring.
const lightbulbURIPath : bitstring.

const CoAP_GETCode : bitstring.
const CoAP_POSTCode : bitstring.
const CoAP_CHANGEDCode : bitstring.
const CoAP_CONTENTCode : bitstring.
const CoAP_EMPTYCode : bitstring.

const OSCORE_option_code : bitstring.

const acknowledgement: bitstring.
const non_confirmable: bitstring.
const confirmable: bitstring.

const coap_version_one:bitstring.
const oscore_version_one:bitstring.
const encrypt0:bitstring.

const AES_CCM: bitstring.

(* HKDF *)
const HKDF_256: bitstring.

free initiator, responder : host.

(**)
fun HKDF(bitstring, bitstring, bitstring, bitstring): key.
fun alg_key_length(bitstring, bitstring): bitstring.
fun bounded_by(bitstring):bitstring.
fun bounded_by_hosts(host, host):bitstring.
fun aeadEncrypt(key, nonce, bitstring, bitstring): bitstring.

event here.
event startInitiator(host, host, bitstring).
event startInit(host, host, bitstring).
event endResponder(host, host, bitstring).
event sendResponder(host, host, bitstring).
event responseReceived(host, host, bitstring).
(*token + security_context *)
event request_binding(bitstring, bitstring).
event response_binding(bitstring, bitstring).
(* Injective agreement Symmetric *)
query attacker(new msg1id) phase 1. (* Forward secrecy does NOT work *)
query attacker(new msg1id) phase 0. (* Secrecy does work *)
query attacker(new msg2id) phase 1. (* Forward secrecy does NOT work *)
query attacker(new msg2id) phase 0. (* Secrecy does work *)
query event(here).

(*Injective agreement*)
query A:host, B:host, p:bitstring; inj-event (endResponder(A,B,p)) ==> inj-event(startInitiator(A,B,p)).
(*)
query A:host, B:host, p:bitstring; event (sendResponder(A,B,bounded_by(p))) ==> event(startInit(A,B,p)).

(*Request-response binding: An attacker should not be able to make a
      client match a response to the wrong request. *)
      (*)
query token:bitstring, security_context:bitstring, fake_security_context:bitstring; event(response_binding(token, fake_security_context)) ==> event (request_binding(token, security_context)).
(*
Non-replayability: An attacker should not be able to cause the
receiver to accept a message which it has previously received and
accepted.
      *)
fun aeadNonce(id, bitstring, key) : nonce.

reduc forall plaintext: bitstring, n: nonce, k: key, aad: bitstring; aeadDecrypt(aeadEncrypt(k, n, plaintext, aad), k, n, aad) = plaintext.
reduc forall plaintext: bitstring, n: nonce, k: key, aad: bitstring; decrypt(aeadEncrypt(k, n, plaintext, aad), k, n) = plaintext.

table security_context_lookup(host, host, id, id, bitstring, bitstring, bitstring).
table token_to_message_lookup(host, bitstring, bitstring).
table replay_window(host, bitstring).

let oscore_initiator =
  in(c, (identity: host, endpoint: host));
	if identity = initiator || identity = responder then
  new token : bitstring;
  new messageid : bitstring;
  new partial_iv: bitstring;
  in(c, (endpoint: host));
  get security_context_lookup(=identity, =endpoint, senderID:id, recipientID:id, msecret:bitstring, msalt:bitstring, idcontext:bitstring) in (*Find a security context with endpoint*)
  let cvInfo = (emptyId, idcontext, AES_CCM, label_iv) in let CommonIv = HKDF(msecret, msalt, cvInfo, alg_key_length(AES_CCM, label_iv)) in
  let senderInfo = (senderID, idcontext, AES_CCM, label_key) in let senderKey = HKDF(msecret, msalt, senderInfo, alg_key_length(AES_CCM, label_key)) in

  let aad = (encrypt0, oscore_version_one, AES_CCM, senderID, partial_iv) in
  let aead_nonce = aeadNonce(senderID, partial_iv, CommonIv) in

  new msg1id:bitstring;
  let plaintext = ((CoAP_GETCode, isLightBulbTurnedOn), (msg1id)) in
  let ciphertext = aeadEncrypt(senderKey, aead_nonce, plaintext, aad) in
  let oscore_option = (partial_iv, senderID, idcontext) in
  let msg_1 = (
    (*Header*)
    coap_version_one,
    non_confirmable,
    bounded_by(token), (*Token length is a value bounded by token*)
    CoAP_POSTCode,
    messageid,
    (*Body*)
    token,
    oscore_option,
    ciphertext) in
  let security_context = (endpoint, senderID, recipientID, idcontext, partial_iv, aead_nonce) in
  insert token_to_message_lookup(identity, token, security_context);
  event startInitiator(identity, endpoint, (CoAP_GETCode, isLightBulbTurnedOn));
  out(c, msg_1).

let oscore_initiator_response_receiver =
(*Extend to allow messages to send ACK if confirmable*)
  in(c, (identity: host));
  if identity = initiator || identity = responder then
  in(c, (=coap_version_one, =non_confirmable,
      tlength: bitstring, discard : bitstring,
      messageid : bitstring, token: bitstring,
      =empty, (*The OSCORE option*)
      ciphertext:bitstring)); (*The encrypted payload*)
  get token_to_message_lookup(=identity, =token, security_context:bitstring) in
  event response_binding(token, security_context);
  let (endpoint:host, senderID:id, recipientID:id, idcontext:bitstring, partial_iv:bitstring, aead_nonce:nonce) = security_context in
  get security_context_lookup(=identity, =endpoint, =senderID, =recipientID, msecret:bitstring, msalt:bitstring, =idcontext) in (*Find a security context with endpoint*)
  let aad = (encrypt0, oscore_version_one, AES_CCM, senderID, partial_iv) in
  let recipientInfo = (recipientID, idcontext, AES_CCM, label_key) in let recipientKey = HKDF(msecret, msalt, recipientInfo, alg_key_length(AES_CCM, label_key)) in
  let (plaintext:bitstring, identifier:bitstring) = aeadDecrypt(ciphertext, recipientKey, aead_nonce, aad) in
  event here;
  event responseReceived(identity, endpoint, plaintext).

let oscore_responder =
  in(c, (identity: host, endpoint: host));
  if identity = initiator || identity = responder then
  in(c, (=coap_version_one, T:bitstring,
        tlength: bitstring, discard : bitstring,
        messageid : bitstring, token: bitstring,
        (partial_iv:bitstring, recipientID:id, idcontext:bitstring), (*The OSCORE option*)
        ciphertext:bitstring));
  if T = confirmable then
    out(c, (coap_version_one, acknowledgement, CoAP_EMPTYCode, messageid));

  get security_context_lookup(=identity, endpoint:host, senderID:id, =recipientID, msecret:bitstring, msalt:bitstring, =idcontext) in (*Find a security context with endpoint*)
  let cvInfo = (emptyId, idcontext, AES_CCM, label_iv) in let commonIV = HKDF(msecret, msalt, cvInfo, alg_key_length(AES_CCM, label_iv)) in
  let recipientInfo = (recipientID, idcontext, AES_CCM, label_key) in let recipientKey = HKDF(msecret, msalt, recipientInfo, alg_key_length(AES_CCM, label_key)) in
  let aad = (encrypt0, oscore_version_one, AES_CCM, recipientID, partial_iv) in
  let aead_nonce = aeadNonce(recipientID, partial_iv, commonIV) in

  (*This does not work properly :( )*)
  let (plaintext:bitstring, identifier:bitstring) = aeadDecrypt(ciphertext, recipientKey, aead_nonce, aad) in
  get replay_window(=identity, partial:bitstring) suchthat partial = partial_iv in out(c, partial) else
  insert replay_window(identity, partial_iv);
  new msg2id : bitstring;

  new responseId : bitstring;
  (*To enable the receiver
   to act only once on the message, Non-confirmable messages specify a
   Message ID as well.*)
  let responsePayload = bounded_by(plaintext) in (*Response payload is bounded by the plaintext*)
  let sender_info = (senderID, idcontext, AES_CCM, label_key) in let senderKey = HKDF(msecret, msalt, sender_info, alg_key_length(AES_CCM, label_key)) in
  let sender_ciphertext = aeadEncrypt(senderKey, aead_nonce, ((CoAP_CONTENTCode, responsePayload), msg2id), aad) in
  let msg_2 = (
    (*Header*)
    coap_version_one,
    non_confirmable,
    bounded_by(token), (*Token length is a value bounded by token*)
    CoAP_CHANGEDCode,
    responseId,
    (*Body*)
    token,
    empty,
    sender_ciphertext) in
  event endResponder(endpoint, identity, plaintext);
  out(c, msg_2).

let init =
  in(c, (a: host, b: host, senderID:id, recipientID:id, ms: bitstring, msalt:bitstring, idcontext: bitstring));
  if a <> initiator && b <> responder then
    if b <> initiator && a <> responder then
      insert security_context_lookup(a, b, senderID, recipientID, ms, msalt, idcontext);
      insert security_context_lookup(b, a, recipientID, senderID, ms, msalt, idcontext).

process
  new IDir:id; new IDri:id; new msecret : bitstring; new msalt:bitstring; new idcontext: bitstring;
  (*Consider a shared table where all users are well behaved, and ONLY reads rows which belongs to them*)
  insert security_context_lookup(initiator, responder, IDir, IDri, msecret, msalt, idcontext);
  insert security_context_lookup(responder, initiator, IDri, IDir, msecret, msalt, idcontext);
  (*These are the actors in our model*)
  (!oscore_initiator) |
  (!oscore_initiator_response_receiver) |
  (!oscore_responder) |
  (!init) |
  (phase 1; out(c, (msecret, msalt)))
