free c: channel.

type symk.
fun sesskey(symk, symk, bitstring): symk [private].
fun symk_to_bitstring(symk): bitstring[data, typeConverter].
fun senc(bitstring, symk): bitstring.
reduc forall x: bitstring, k:symk; sdec(senc(x,k), k) = x.

(* Declare 2 honest hosts *)
type host.
free A, B: host.

event beginAparam(host).
event endAparam(host).
event beginBparam(host, bitstring).
event endBparam(host, bitstring).
event protocolFinishB(symk).
event protocolFinishA(symk).
event dishonest(symk).
event notSameKeys.
(* Key table *)
query x: host,y:bitstring; inj-event(endBparam(x,y)) ==> inj-event(beginBparam(x,y)).
query x: host; inj-event(endAparam(x)) ==> inj-event(beginAparam(x)).
free secretANa, secretANb, secretBNa, secretBNb: bitstring[private].

query attacker(new kAS).
query attacker(new kBS).
query kA: symk, kB: symk, rnd: bitstring;
  attacker(sesskey(kA, kB, rnd)) ==> (event (dishonest(kA)) || event (dishonest(kB))).
query event (notSameKeys).
query attacker(secretANa);
      attacker(secretANb);
      attacker(secretBNa);
      attacker(secretBNb).

fun benc(bitstring, bitstring): bitstring.
reduc forall x: bitstring, y: bitstring; bdec(benc(x,y), y) = x.

(* the table host names/keys
   The key table consists of pairs
   (host, key shared between the host and the server) *)
table keys(host, symk).

let processA =
  in(c, (xB0: host));
  get keys(=A, kA) in

  new nA: bitstring;
  new identifier: bitstring;
  event beginBparam(xB0, identifier);
  out(c, (identifier, A, xB0, senc((nA, identifier, A, xB0), kA))); (*Message 1*)
  in(c, (=identifier, msg4: bitstring)); (*Message 4*)

  let(=nA, keyAB: symk) = sdec(msg4, kA) in
  event endAparam(A)
  (*if xB0 = B then
    event endAparam(A);
    event protocolFinishA(keyAB);
    out(c, senc(symk_to_bitstring(keyAB), keyAB));
    in(c, samekey: bitstring);
    let (bsABkey) = sdec(samekey, keyAB) in
    if bsABkey <> symk_to_bitstring(keyAB) then
      event notSameKeys();
    out(c, benc(secretANa, nA));
    out(c, senc(secretANb, keyAB))*).


let processB =
  get keys(=B, kB) in
  in(c, (identifier: bitstring, xA1: host, =B, msg2: bitstring)); (*Message 1*)
  event beginAparam(xA1); (*Event that protocol started in processB *)

  new nB: bitstring;
  out(c, (identifier, xA1, B, msg2, senc((nB, identifier, xA1, B), kB))); (*Message 2*)

  in(c, (=identifier, aKey: bitstring, bKey: bitstring)); (*Message 3*)
  let (=nB, keyAB: symk) = sdec(bKey, kB) in

  out(c, (identifier, aKey)) (*Message 4*)

  (*if xA1 = A then
    event endBparam(B, identifier);
    event protocolFinishB(keyAB);
    out(c, senc(symk_to_bitstring(keyAB), keyAB));
    in(c, samekey:bitstring);
    let (bsABkey) = sdec(samekey, keyAB) in
    if bsABkey <> symk_to_bitstring(keyAB) then
      event notSameKeys();
    out(c, benc(secretBNa, nB));
    out(c, senc(secretBNb, keyAB))*).

let processS =
  in(c, (identifier: bitstring, a: host, b: host, encA: bitstring, encB: bitstring));
  get keys(=a, kA1) in
  get keys(=b, kB1) in
  let(nonceA: bitstring, =identifier, =a, =b) = sdec(encA, kA1) in
  let(nonceB: bitstring, =identifier, =a, =b) = sdec(encB, kB1) in
  new rnd:bitstring;
  let k = sesskey(kA1, kB1, rnd) in
  out(c, (identifier, senc((nonceA, k), kA1),
                      senc((nonceB, k), kB1))).
let processK =
    in(c, (h: host, k: symk));
    event dishonest(k);
    if h <> A && h <> B then insert keys(h,k).

process
  new kAS: symk;
  new kBS: symk;
  insert keys(A, kAS);
  insert keys(B, kBS);
  (
    (!processA()) |
    (!processB()) |
    (!processS()) |
    (!processK())
    )
    (* Check injectivity *)
    (* Check that A and B ends up with the same key *)
    (* Prove that if the server creates a session key then theres injective agreement between the two clients. Between the server and between eac h of the two clients. *)
